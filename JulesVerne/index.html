<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Innioasis Y1 Themes - Theme Info</title>
    <meta name="description"
        content="Download theme for Innioasis Y1 MP3 player. Official community theme repository endorsed by Innioasis. Community Maintainers: Ryan Specter + Dmitri Medina">
    <meta name="keywords"
        content="Innioasis Y1, Y1 themes, MP3 player themes, Y1 customization, official Y1 themes, Ryan Specter, Dmitri Medina">
    <script type="application/ld+json">
    {{
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "Theme",
        "applicationCategory": "Theme",
        "operatingSystem": "Innioasis Y1",
        "description": "Download theme for Innioasis Y1 MP3 player. Official community theme repository endorsed by Innioasis. Community Maintainers: Ryan Specter + Dmitri Medina",
        "url": "https://themes.innioasis.app/",
        "publisher": {{
            "@type": "Organization",
            "name": "Innioasis Y1 Community",
            "url": "https://themes.innioasis.app"
        }},
        "maintainer": [
            {{
                "@type": "Person",
                "name": "Ryan Specter",
                "url": "https://ryanspecter.uk"
            }},
            {{
                "@type": "Person",
                "name": "Dmitri Medina",
                "url": "https://reddit.com/user/dmitrimedina"
            }}
        ]
    }}
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            margin: 0;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 100%;
            text-align: center;
            margin-bottom: 20px;
        }

        /* Scale theme pages to 110% on desktop */
        @media (min-width: 768px) {
            html {
                font-size: 110%;
            }
        }

        h1 {
            margin-bottom: 10px;
            color: #333;
        }

        .author {
            color: #666;
            margin-bottom: 20px;
            font-style: italic;
        }

        .description {
            line-height: 1.6;
            margin-bottom: 30px;
            color: #444;
        }

        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .gallery-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .screenshot {
            width: 100%;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            object-fit: contain;
            transition: transform 0.2s;
            cursor: pointer;
        }

        .screenshot:hover {
            transform: scale(1.02);
        }

        .image-label {
            margin-top: 8px;
            font-size: 0.8rem;
            color: #888;
        }

        .btn {
            width: 100%;
            padding: 12px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 44px;
            max-height: 44px;
            box-sizing: border-box;
            overflow: hidden;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5), 0 0 2px rgba(0, 0, 0, 0.8);
            position: relative;
            border: none;
            transition: all 0.3s;
        }

        .btn:hover,
        .btn:focus {
            /* No transform - buttons should not grow on hover */
            transform: none;
        }

        .btn.install {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .btn.download {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .btn.share {
            background: transparent;
            color: #666;
            border: 1px solid #ddd;
            padding: 12px 16px;
            font-size: 0.95rem;
            box-shadow: none;
            text-shadow: none;
            width: 100%;
        }

        .btn.share:hover {
            background: #f5f5f5;
            border-color: #667eea;
            color: #667eea;
            /* No transform - buttons should not grow on hover */
        }

        /* Ensure button content is always visible above background */
        .btn>span {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            gap: 8px;
            position: relative;
            z-index: 2;
        }

        .btn>span>span:first-child {
            position: relative;
            z-index: 3;
            flex: 1;
            text-align: left;
        }

        .btn img {
            height: 100%;
            max-height: 100%;
            width: auto;
            flex-shrink: 0;
            object-fit: contain;
            display: block;
            position: relative;
            z-index: 3;
        }

        /* Arrow icon - hidden by default, shown on hover/tap/hold */
        /* Arrow icon matches button height (44px) and is centered vertically on the right */
        .btn .arrow-icon {
            height: 44px;
            max-height: 44px;
            width: 0;
            overflow: hidden;
            flex-shrink: 0;
            opacity: 0;
            visibility: hidden;
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 3;
            transition: opacity 0.2s, visibility 0.2s, width 0.2s;
            display: flex;
            align-items: center;
        }

        .btn .arrow-icon img {
            height: 44px;
            max-height: 44px;
            width: auto;
            flex-shrink: 0;
            object-fit: contain;
            display: block;
        }

        .reddit-favicon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-left: 4px;
            vertical-align: middle;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .reddit-favicon:hover {
            opacity: 1;
        }

        .reddit-favicon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Show arrow on hover/focus/active for desktop (or mobile with mouse) */
        /* @media (hover: hover) means device has hover capability (mouse, trackpad, etc.) */
        @media (hover: hover) {

            .btn:hover .arrow-icon,
            .btn:focus .arrow-icon,
            .btn:active .arrow-icon {
                opacity: 1;
                visibility: visible;
                width: auto;
            }
        }

        /* Show arrow on mobile when button is active/touched */
        /* Arrow only shows when finger is held down (touchstart) */
        @media (hover: none) {

            .btn:active .arrow-icon,
            .btn.touching .arrow-icon {
                opacity: 1;
                visibility: visible;
                width: auto;
            }
        }

        @font-face {
            font-family: 'ThemeFont';
            src: url('None');
        }

        .header-section {
            display: flex;
            align-items: center;
            gap: 30px;
            margin-bottom: 20px;
        }

        .header-text {
            flex: 1;
        }

        .cover-image {
            width: 200px;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .cover-image:hover {
            transform: scale(1.05);
        }

        .screenshots-section {
            margin: 30px 0;
        }

        .screenshots-section h3 {
            color: #667eea;
            margin-bottom: 15px;
        }

        /* Image Carousel */
        .image-carousel-section {
            margin: 30px 0;
        }

        .image-carousel-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .image-carousel-container {
            position: relative;
            width: 100%;
            overflow: hidden;
            background: #f5f5f5;
            border-radius: 8px;
            padding: 10px;
        }

        .image-carousel-wrapper {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            scroll-behavior: smooth;
            scrollbar-width: thin;
            scrollbar-color: #667eea #f5f5f5;
            padding: 5px 0;
        }

        .image-carousel-wrapper::-webkit-scrollbar {
            height: 6px;
        }

        .image-carousel-wrapper::-webkit-scrollbar-track {
            background: #f5f5f5;
            border-radius: 3px;
        }

        .image-carousel-wrapper::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 3px;
        }

        .image-carousel-item {
            flex: 0 0 auto;
            width: 120px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .image-carousel-item:hover {
            transform: scale(1.05);
        }

        .image-carousel-item img {
            width: 100%;
            height: 80px;
            object-fit: contain;
            background-image:
                linear-gradient(45deg, #f0f0f0 25%, transparent 25%),
                linear-gradient(-45deg, #f0f0f0 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #f0f0f0 75%),
                linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
            background-size: 12px 12px;
            background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
            border-radius: 4px;
            border: 1px solid #ddd;
            padding: 4px;
        }

        .image-carousel-item .image-name {
            margin-top: 5px;
            font-size: 0.75rem;
            color: #666;
            word-break: break-word;
            line-height: 1.2;
        }

        /* Screenshots Gallery - Larger carousel */
        .screenshots-carousel-item {
            flex: 0 0 auto;
            width: 250px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .screenshots-carousel-item:hover {
            transform: scale(1.02);
        }

        .screenshots-carousel-item img {
            width: 100%;
            height: 180px;
            object-fit: contain;
            background: white;
            border-radius: 6px;
            border: 1px solid #ddd;
            padding: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .screenshots-carousel-wrapper::-webkit-scrollbar {
            height: 8px;
        }

        .screenshots-carousel-wrapper::-webkit-scrollbar-track {
            background: #f5f5f5;
            border-radius: 4px;
        }

        .screenshots-carousel-wrapper::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .image-carousel-nav {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }

        .image-carousel-nav-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .image-carousel-nav-btn:hover {
            background: #5568d3;
        }

        .image-carousel-nav-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .image-carousel-nav-info {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            color: #666;
            padding: 0 10px;
        }

        /* Lightbox */
        .lightbox {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
        }

        .lightbox.active {
            display: flex;
        }

        .lightbox-content {
            max-width: 90%;
            max-height: 90%;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            font-size: 1.1rem;
            /* Better legibility */
        }

        .lightbox-content h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }

        .lightbox-content p {
            font-size: 1rem;
            line-height: 1.6;
        }

        .lightbox-content pre,
        .lightbox-content code {
            font-size: 0.95rem;
            line-height: 1.6;
        }

        @media (max-width: 767px) {
            .lightbox-content {
                max-width: 95%;
                max-height: 95%;
                font-size: 1rem;
                padding: 15px;
            }

            .lightbox-content h3 {
                font-size: 1.3rem;
            }

            .lightbox-content pre,
            .lightbox-content code {
                font-size: 0.85rem;
            }
        }

        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 30px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.3s;
        }

        .lightbox-close:hover {
            color: #bbb;
        }

        .lightbox-edit-btn {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(102, 126, 234, 0.9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1001;
        }

        .lightbox-edit-btn:hover {
            background: rgba(102, 126, 234, 1);
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
        }

        .lightbox-edit-btn:active {
            transform: translateX(-50%) translateY(0);
        }

        .back-link {
            display: block;
            margin-top: 20px;
            color: #666;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        /* Existing CSS */
        .bg-cycle {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            filter: blur(20px) brightness(0.5);
            z-index: -1;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        /* Download link when install is available */
        .download-link-small {
            font-size: 0.85rem;
            color: #667eea;
            text-decoration: none;
            margin-left: 10px;
        }

        .download-link-small:hover {
            text-decoration: underline;
        }

        /* Button group - constrained width to match home page theme card buttons */
        .button-group {
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Install Instructions Modal */
        .install-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
        }

        .install-modal.active {
            display: flex;
        }

        .install-modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .install-modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            line-height: 1;
        }

        .install-modal-close:hover {
            color: #333;
        }

        .install-modal h3 {
            margin-top: 0;
            color: #667eea;
            font-size: 1.3rem;
        }

        .install-modal ol {
            margin: 20px 0;
            padding-left: 25px;
        }

        .install-modal li {
            margin: 10px 0;
            line-height: 1.6;
        }

        .install-modal-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            width: 100%;
        }

        .install-modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        /* Loading animations - subtle pulse effect */
        @keyframes loading-pulse {

            0%,
            100% {
                opacity: 0.4;
            }

            50% {
                opacity: 0.7;
            }
        }

        @keyframes loading-shimmer {
            0% {
                background-position: -1000px 0;
            }

            100% {
                background-position: 1000px 0;
            }
        }

        .loading-placeholder {
            animation: loading-pulse 1.5s ease-in-out infinite;
            background: linear-gradient(90deg, #f0f0f0 0%, #e0e0e0 50%, #f0f0f0 100%);
            background-size: 1000px 100%;
            border-radius: 4px;
            min-height: 1em;
            display: inline-block;
            width: 100%;
        }

        .loading-text {
            animation: loading-pulse 1.5s ease-in-out infinite;
            color: #999 !important;
        }

        .loading-skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading-shimmer 1.5s ease-in-out infinite;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <!-- 
    IMPORTANT: This page is designed to load information programmatically.
    
    DATA LOADING PRIORITY (Source of Truth):
    1. config.json (in this theme's folder) = AUTHORITATIVE SOURCE
    2. themes.json (in parent directory) = FAST CACHE/FALLBACK
    3. Hardcoded values in this HTML = LAST RESORT ONLY
    
    This design allows users to:
    - Copy this index.html to another theme folder without editing it
    - Update theme info by editing config.json or themes.json
    - The page will automatically use the most up-to-date information
    
    All theme data (name, author, description, colors, images) should be loaded
    from config.json or themes.json when possible, not from hardcoded HTML.
    -->
    <div class="container">
        <div class="header-section">
            <div class="header-text">
                <!-- Title and subtitle removed; using About line instead -->
                <h2 id="theme-title" style="font-size: 1rem; margin-bottom: 15px; color: #667eea;">
                    <span class="loading-placeholder"
                        style="width: 300px; height: 1.2em; display: inline-block;"></span>
                </h2>
                <p class="description" id="theme-description">
                    <span class="loading-placeholder"
                        style="width: 400px; height: 1.2em; display: inline-block;"></span>
                </p>
                <p class="author-info" style="margin-top: 15px; color: #666; font-size: 0.9rem; font-style: italic;">
                    Theme created by <strong id="author-display">
                        <span class="loading-placeholder"
                            style="width: 150px; height: 1em; display: inline-block;"></span>
                    </strong>
                </p>
            </div>
            <img src="" alt="Theme cover" class="cover-image" id="cover-image" style="display: none;">
        </div>



        <!-- Screenshots Gallery (larger carousel) -->
        <div class="screenshots-gallery-section" style="margin: 30px 0;">
            <h3 style="font-size: 1.1rem; margin-bottom: 15px; color: #667eea; font-weight: 600;">Screenshots</h3>
            <div class="screenshots-carousel-container"
                style="position: relative; width: 100%; overflow: hidden; background: #f5f5f5; border-radius: 8px; padding: 15px;">
                <div class="screenshots-carousel-wrapper" id="screenshots-carousel-wrapper"
                    style="display: flex; gap: 15px; overflow-x: auto; scroll-behavior: smooth; scrollbar-width: thin; scrollbar-color: #667eea #f5f5f5; padding: 5px 0;">
                    <div style="text-align: center; padding: 40px; color: #999; width: 100%;">
                        <div class="loading-skeleton"
                            style="width: 250px; height: 180px; margin: 0 auto; border-radius: 6px;"></div>
                        <p style="margin-top: 15px;" class="loading-text">Loading screenshots...</p>
                    </div>
                </div>
                <div class="screenshots-carousel-nav"
                    style="display: flex; justify-content: center; gap: 8px; margin-top: 15px;">
                    <button class="image-carousel-nav-btn" id="screenshots-prev"
                        onclick="scrollScreenshotsCarousel(-1)">‚Üê Prev</button>
                    <div class="image-carousel-nav-info" id="screenshots-info">- / -</div>
                    <button class="image-carousel-nav-btn" id="screenshots-next"
                        onclick="scrollScreenshotsCarousel(1)">Next ‚Üí</button>
                </div>
            </div>
        </div>

        <div class="image-carousel-section">
            <h3 style="font-size: 1rem; margin-bottom: 15px; color: #667eea;">Theme Assets</h3>
            <div class="image-carousel-container">
                <div class="image-carousel-wrapper" id="image-carousel-wrapper">
                    <div style="text-align: center; padding: 20px; color: #999;">
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <div class="loading-skeleton" style="width: 120px; height: 80px; border-radius: 4px;"></div>
                            <div class="loading-skeleton" style="width: 120px; height: 80px; border-radius: 4px;"></div>
                            <div class="loading-skeleton" style="width: 120px; height: 80px; border-radius: 4px;"></div>
                            <div class="loading-skeleton" style="width: 120px; height: 80px; border-radius: 4px;"></div>
                        </div>
                        <p style="margin-top: 15px;" class="loading-text">Loading theme assets...</p>
                    </div>
                </div>
                <div class="image-carousel-nav">
                    <button class="image-carousel-nav-btn" id="carousel-prev" onclick="scrollCarousel(-1)">‚Üê
                        Prev</button>
                    <div class="image-carousel-nav-info" id="carousel-info">- / -</div>
                    <button class="image-carousel-nav-btn" id="carousel-next" onclick="scrollCarousel(1)">Next
                        ‚Üí</button>
                </div>
            </div>
        </div>

        <div class="button-group" style="margin-top: 30px;">
            <button id="install-btn" onclick="showInstallInstructions()" class="btn install" style="display: none;">
                <span
                    style="display: flex; align-items: center; justify-content: space-between; width: 100%; position: relative; z-index: 2;">
                    <span style="position: relative; z-index: 3; flex: 1; text-align: left;">Install</span>
                </span>
            </button>
            <button id="download-btn-full" onclick="downloadTheme()" class="btn download">
                <span
                    style="display: flex; align-items: center; justify-content: space-between; width: 100%; position: relative; z-index: 2;">
                    <span style="position: relative; z-index: 3; flex: 1; text-align: left;">Download</span>
                </span>
            </button>
            <a href="#" id="download-link-small" onclick="downloadTheme(); return false;" class="download-link-small"
                style="display: none;">üì¶ Download ZIP instead</a>
            <button onclick="shareTheme()" class="btn share" style="margin-top: 10px;">
                <span style="display: flex; align-items: center; justify-content: center; width: 100%;">
                    <span>üîó Share this Theme</span>
                </span>
            </button>
        </div>
        <div id="download-status" style="margin-top: 10px; color: #666; display: none;">Starting download...</div>

        <!-- Install Instructions Modal -->
        <div id="install-modal" class="install-modal" onclick="if(event.target === this) closeInstallModal()">
            <div class="install-modal-content" onclick="event.stopPropagation()">
                <span class="install-modal-close" onclick="closeInstallModal()">&times;</span>
                <h3>Prepare Your Y1 Device</h3>
                <p>Before installing, please follow these steps:</p>
                <ol id="install-steps-list">
                    <li><strong>Power up your Y1 device</strong></li>
                    <li><strong>Connect your Y1 to your device via USB</strong></li>
                    <li><strong>Enable USB storage mode</strong> on your Y1 (if prompted)</li>
                    <li id="android-step" style="display: none;"><strong>On Android:</strong> Press the <strong>‚ò∞ (three
                            lines/hamburger menu)</strong> button at the top left of the file picker, then navigate to
                        and select your Y1's <strong>"Themes" folder</strong> from the USB drive</li>
                    <li id="desktop-step"><strong>On the next screen, select the "Themes" folder</strong> on your Y1
                        device</li>
                </ol>
                <p style="color: #666; font-size: 0.9rem; margin-top: 15px;">The installation will automatically copy
                    all theme files to your device.</p>
                <button class="install-modal-btn" onclick="proceedWithInstall()">Continue to Folder Selection</button>
                <p style="text-align: center; margin-top: 15px;">
                    <a href="#" onclick="closeInstallModal(); downloadTheme(); return false;"
                        style="color: #667eea; text-decoration: underline; font-size: 0.9rem;">üì¶ Download as .zip
                        instead</a>
                </p>
            </div>
        </div>

        <!-- Feature Support Section -->
        <!-- This section shows upcoming or region-specific features that need images added -->
        <div id="feature-support-section" style="margin-top: 30px; display: none;">
            <div id="unsupported-features"
                style="background: #f9f9f9; border-radius: 8px; padding: 15px; border-left: 4px solid #ff9800;">
                <p style="margin: 0 0 10px 0; font-weight: 600; color: #666;">To the creator:</p>
                <p style="margin: 0 0 10px 0; font-size: 0.9rem; color: #666;">Add these images to your theme to ensure
                    compatibility with these upcoming or region-specific features:</p>
                <ul id="unsupported-features-list"
                    style="margin: 0 0 10px 0; padding-left: 20px; color: #888; list-style-type: disc;">
                    <!-- Features will be populated dynamically with links to config.json -->
                </ul>
                <p style="margin: 10px 0 0 0; font-size: 0.85rem; color: #999; font-style: italic;">
                    These features may not be available to users at present but are defined in the theme spec in
                    firmware 2.8.2 and are to be expected in future releases and where features are only available in
                    certain regions.
                </p>
            </div>
        </div>

        <!-- SEO Content -->
        <div class="seo-content"
            style="margin-top: 40px; text-align: left; color: #666; font-size: 0.9rem; line-height: 1.6;">
            <p><span id="description-display">
                    <span class="loading-placeholder"
                        style="width: 500px; height: 1.2em; display: inline-block;"></span>
                </span></p>
        </div>

        <div style="margin-top: 30px; font-size: 0.9rem; color: #888;">
            <a href="../index.html" class="back-link">‚Üê Back to All Themes</a>
            <span style="margin: 0 10px;">|</span>
            <a href="#" id="edit-theme-link" target="_blank" style="color: #888; text-decoration: none;">‚úèÔ∏è Edit or
                Update this Theme</a>
        </div>
    </div>

    <!-- Lightbox Modal -->
    <div id="lightbox" class="lightbox" onclick="closeLightbox()">
        <span class="lightbox-close" onclick="closeLightbox()">&times;</span>
        <button id="lightbox-nav-left" class="lightbox-nav-btn"
            style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%); background: rgba(255, 255, 255, 0.9); border: none; border-radius: 50%; width: 50px; height: 50px; font-size: 24px; cursor: pointer; z-index: 1003; display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s;"
            onclick="event.stopPropagation(); navigateAsset(-1)"
            onmouseover="this.style.background='rgba(255, 255, 255, 1)'"
            onmouseout="this.style.background='rgba(255, 255, 255, 0.9)'">‚Üê</button>
        <button id="lightbox-nav-right" class="lightbox-nav-btn"
            style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); background: rgba(255, 255, 255, 0.9); border: none; border-radius: 50%; width: 50px; height: 50px; font-size: 24px; cursor: pointer; z-index: 1003; display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: all 0.3s;"
            onclick="event.stopPropagation(); navigateAsset(1)"
            onmouseover="this.style.background='rgba(255, 255, 255, 1)'"
            onmouseout="this.style.background='rgba(255, 255, 255, 0.9)'">‚Üí</button>
        <img class="lightbox-content" id="lightbox-img" onclick="event.stopPropagation()">
        <div id="lightbox-content-wrapper"
            style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 90%; max-height: 80%; overflow-y: auto; background: white; border-radius: 8px; padding: 30px; box-shadow: 0 10px 40px rgba(0,0,0,0.5); z-index: 1001;"
            onclick="event.stopPropagation()"></div>
        <div id="lightbox-json-context"
            style="display: none; position: fixed; right: 20px; top: 50%; transform: translateY(-50%); width: 380px; max-width: calc(100vw - 40px); background: rgba(45, 45, 45, 0.98); border-radius: 8px; padding: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.5); z-index: 1002; max-height: 70vh; overflow-y: auto; border: 1px solid rgba(255,255,255,0.1);"
            onclick="event.stopPropagation()"></div>
        <div id="lightbox-filename"
            style="position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.8); color: white; padding: 8px 16px; border-radius: 4px; font-size: 0.9rem; max-width: 90%; text-align: center; word-break: break-word; z-index: 1002;">
        </div>
        <a id="lightbox-edit-btn" class="lightbox-edit-btn" href="#" target="_blank" rel="noopener noreferrer"
            onclick="event.stopPropagation()">
            <span>‚úèÔ∏è</span>
            <span>View/Edit on GitHub</span>
        </a>
    </div>

    <!-- Toast Notification -->
    <div id="toast"
        style="visibility: hidden; min-width: 250px; margin-left: -125px; background-color: #333; color: #fff; text-align: center; border-radius: 2px; padding: 16px; position: fixed; z-index: 1; left: 50%; bottom: 30px; font-size: 17px;">
        Link Copied to Clipboard!</div>

    <div class="footer"
        style="margin-top: 50px; text-align: center; color: #eee; font-size: 0.9rem; padding-bottom: 20px;">
        <p><strong>Community Maintainers:</strong> <a href="https://ryanspecter.uk" target="_blank"
                style="color: #fff; text-decoration: underline;">Ryan Specter</a> & <a
                href="https://reddit.com/user/dmitrimedina" target="_blank"
                style="color: #fff; text-decoration: underline;">Dmitri Medina</a></p>
        <p>BETA | This site is open source. <a href="https://github.com/y1-community/InnioasisY1Themes" target="_blank"
                style="color: #fff;">Contribute on GitHub</a></p>
    </div>

    <!-- Support Toolbar -->
    <style>
        #support-toolbar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            padding: 8px 12px;
            background: #f0f0f3;
            border-radius: 30px;
            box-shadow:
                8px 8px 16px rgba(163, 177, 198, 0.6),
                -8px -8px 16px rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
            flex-wrap: wrap;
        }

        .support-toolbar-btn {
            background: #f0f0f3;
            border: none;
            border-radius: 25px;
            padding: 10px 18px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #2d2d2d;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow:
                4px 4px 8px rgba(163, 177, 198, 0.6),
                -4px -4px 8px rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .support-toolbar-btn:hover {
            box-shadow:
                2px 2px 4px rgba(163, 177, 198, 0.6),
                -2px -2px 4px rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .support-toolbar-btn:active {
            box-shadow:
                inset 2px 2px 4px rgba(163, 177, 198, 0.6),
                inset -2px -2px 4px rgba(255, 255, 255, 0.5);
            transform: translateY(0);
        }

        .support-toolbar-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow:
                4px 4px 8px rgba(102, 126, 234, 0.4),
                -4px -4px 8px rgba(118, 75, 162, 0.3);
        }

        .support-toolbar-btn.primary:hover {
            box-shadow:
                2px 2px 4px rgba(102, 126, 234, 0.4),
                -2px -2px 4px rgba(118, 75, 162, 0.3);
        }

        .support-toolbar-icon {
            font-size: 16px;
            display: inline-block;
            line-height: 1;
        }

        #donate-options {
            display: none;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        #donate-options.expanded {
            display: flex;
        }

        .crypto-address {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px 12px;
            background: #f0f0f3;
            border-radius: 12px;
            box-shadow:
                2px 2px 4px rgba(163, 177, 198, 0.6),
                -2px -2px 4px rgba(255, 255, 255, 0.5);
            min-width: 140px;
        }

        .crypto-label {
            font-size: 11px;
            font-weight: 700;
            color: #667eea;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .crypto-copy-hint {
            font-size: 9px;
            font-weight: 400;
            color: #86868b;
            text-transform: none;
            letter-spacing: 0;
        }

        .crypto-code {
            font-size: 10px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            color: #2d2d2d;
            word-break: break-all;
            cursor: pointer;
            padding: 4px 6px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .crypto-code:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .crypto-code.copied {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        @media (max-width: 768px) {
            #support-toolbar {
                bottom: 15px;
                right: 15px;
                left: 15px;
                justify-content: center;
                padding: 6px 10px;
                gap: 8px;
                border-radius: 25px;
            }

            .support-toolbar-btn {
                padding: 8px 14px;
                font-size: 12px;
            }

            .support-toolbar-icon {
                font-size: 16px;
            }

            .crypto-address {
                min-width: 120px;
                padding: 6px 10px;
            }

            .crypto-code {
                font-size: 9px;
            }
        }

        @media (prefers-color-scheme: dark) {
            #support-toolbar {
                background: #2d2d2d;
                box-shadow:
                    8px 8px 16px rgba(0, 0, 0, 0.4),
                    -8px -8px 16px rgba(60, 60, 60, 0.3);
            }

            .support-toolbar-btn {
                background: #2d2d2d;
                color: #e0e0e0;
                box-shadow:
                    4px 4px 8px rgba(0, 0, 0, 0.4),
                    -4px -4px 8px rgba(60, 60, 60, 0.3);
            }

            .support-toolbar-btn:hover {
                box-shadow:
                    2px 2px 4px rgba(0, 0, 0, 0.4),
                    -2px -2px 4px rgba(60, 60, 60, 0.3);
            }

            .support-toolbar-btn:active {
                box-shadow:
                    inset 2px 2px 4px rgba(0, 0, 0, 0.4),
                    inset -2px -2px 4px rgba(60, 60, 60, 0.3);
            }

            .crypto-address {
                background: #2d2d2d;
                box-shadow:
                    2px 2px 4px rgba(0, 0, 0, 0.4),
                    -2px -2px 4px rgba(60, 60, 60, 0.3);
            }

            .crypto-code {
                color: #e0e0e0;
                background: rgba(255, 255, 255, 0.05);
            }

            .crypto-code:hover {
                background: rgba(255, 255, 255, 0.1);
            }
        }
    </style>
    <div id="support-toolbar">
        <a href="https://github.com/y1-community/InnioasisY1Themes/tree/main/MelodyMuncher#readme"
            class="support-toolbar-btn primary" target="_blank" rel="noopener noreferrer">
            <span class="support-toolbar-icon">üíô</span>
            <span>Submit Themes</span>
        </a>
        <button id="donate-toggle" class="support-toolbar-btn" type="button">
            <span class="support-toolbar-icon">üí≥</span>
            <span>Donate</span>
        </button>
        <div id="donate-options">
            <a href="https://revolut.me/rspecter" class="support-toolbar-btn" target="_blank" rel="noopener noreferrer">
                <span class="support-toolbar-icon">üí∏</span>
                <span>Revolut</span>
            </a>
            <a href="https://ko-fi.com/teamslide" class="support-toolbar-btn" target="_blank" rel="noopener noreferrer">
                <span class="support-toolbar-icon">‚òï</span>
                <span>Ko-fi</span>
            </a>
            <a href="https://paypal.me/respectyarn" class="support-toolbar-btn" target="_blank"
                rel="noopener noreferrer">
                <span class="support-toolbar-icon">üí≥</span>
                <span>PayPal</span>
            </a>
            <div class="crypto-address">
                <span class="crypto-label">
                    Bitcoin
                    <span class="crypto-copy-hint">(click to copy)</span>
                </span>
                <code class="crypto-code" id="btc-address"
                    onclick="copyCryptoAddress('bc1q9vsjqjr6pjuc3vrgverx0v9ydst8s82ck4kpue', 'btc-address')"
                    title="Click to copy">bc1q9vsjqjr6pjuc3vrgverx0v9ydst8s82ck4kpue</code>
            </div>
            <div class="crypto-address">
                <span class="crypto-label">
                    Ethereum
                    <span class="crypto-copy-hint">(click to copy)</span>
                </span>
                <code class="crypto-code" id="eth-address"
                    onclick="copyCryptoAddress('0x3eec22630ca9fd77D22d362bF6C50dE29D3B84c4', 'eth-address')"
                    title="Click to copy">0x3eec22630ca9fd77D22d362bF6C50dE29D3B84c4</code>
            </div>
        </div>
    </div>
    <script>
        (function () {
            const donateToggle = document.getElementById('donate-toggle');
            const donateOptions = document.getElementById('donate-options');

            donateToggle.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                donateOptions.classList.toggle('expanded');
            });

            // Close when clicking outside
            document.addEventListener('click', function (e) {
                if (!e.target.closest('#support-toolbar')) {
                    donateOptions.classList.remove('expanded');
                }
            });

            function copyCryptoAddress(address, elementId) {
                navigator.clipboard.writeText(address).then(function () {
                    const element = document.getElementById(elementId);
                    const originalText = element.textContent;
                    element.textContent = 'Copied!';
                    element.classList.add('copied');
                    setTimeout(function () {
                        element.textContent = originalText;
                        element.classList.remove('copied');
                    }, 2000);
                }).catch(function (err) {
                    console.error('Failed to copy: ', err);
                    alert('Failed to copy to clipboard. Please copy manually: ' + address);
                });
            }

            // Make copyCryptoAddress available globally
            window.copyCryptoAddress = copyCryptoAddress;
        })();
    </script>

    <script>
        // Helper function to get folder name from URL
        function getFolderName() {
            const currentPath = window.location.pathname;
            const pathParts = currentPath.split('/');
            if (pathParts[pathParts.length - 1].toLowerCase() === 'index.html' || pathParts[pathParts.length - 1] === '') {
                return decodeURIComponent(pathParts[pathParts.length - 2] || '');
            }
            return decodeURIComponent(pathParts[pathParts.length - 1] || '');
        }

        // Share Theme Function
        async function shareTheme() {
            const url = window.location.href;
            const title = document.title;
            const text = "Check out this theme for Innioasis Y1!";

            if (navigator.share) {
                try {
                    await navigator.share({
                        title: title,
                        text: text,
                        url: url
                    });
                    console.log('Shared successfully');
                } catch (err) {
                    console.log('Error sharing:', err);
                }
            } else {
                // Fallback to clipboard
                navigator.clipboard.writeText(url).then(() => {
                    const toast = document.getElementById("toast");
                    toast.style.visibility = "visible";
                    setTimeout(() => { toast.style.visibility = "hidden"; }, 3000);
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    alert('Failed to copy link. URL: ' + url);
                });
            }
        }

        // Load theme font and apply to buttons (like main page)
        async function loadThemeFont() {
            try {
                const configResponse = await fetch('./config.json');
                if (!configResponse.ok) return null;

                const config = await configResponse.json();
                const configStr = JSON.stringify(config);
                const fontMatches = configStr.match(/"([^"]*\.ttf[^"]*)"/gi);

                if (fontMatches && fontMatches.length > 0) {
                    const fontName = fontMatches[0].replace(/"/g, '');
                    const fontUrl = `./${encodeURIComponent(fontName)}`;

                    // Load font using FontFace API
                    try {
                        const fontFace = new FontFace('ThemeFont', `url(${fontUrl})`);
                        await fontFace.load();
                        document.fonts.add(fontFace);
                        return 'ThemeFont';
                    } catch (e) {
                        console.warn('Could not load theme font:', e);
                    }
                }

                // Try common font patterns
                const fontPatterns = ['font.ttf', 'Font.ttf', 'theme.ttf', 'Theme.ttf'];
                for (const fontName of fontPatterns) {
                    try {
                        const fontUrl = `./${encodeURIComponent(fontName)}`;
                        const fontFace = new FontFace('ThemeFont', `url(${fontUrl})`);
                        await fontFace.load();
                        document.fonts.add(fontFace);
                        return 'ThemeFont';
                    } catch (e) {
                        // Continue trying
                    }
                }
            } catch (e) {
                console.warn('Could not load theme font:', e);
            }
            return null;
        }

        // Apply theme styling to buttons
        async function applyThemeButtonStyling() {
            try {
                // Load theme font first
                const themeFont = await loadThemeFont();
                const fontStyle = themeFont ? `font-family: '${themeFont}', sans-serif;` : '';

                const configResponse = await fetch('./config.json');
                if (!configResponse.ok) return;

                const config = await configResponse.json();
                const itemConfig = config?.itemConfig || {};
                const menuConfig = config?.menuConfig || {};
                const dialogConfig = config?.dialogConfig || {};

                // Get button background image - prioritize itemSelectedBackground (buttons are selected items)
                let selectedBgImage = itemConfig.itemSelectedBackground || itemConfig.itemBackground ||
                    menuConfig.menuItemSelectedBackground ||
                    dialogConfig.dialogOptionSelectedBackground || null;

                // IMPORTANT: If config specifies "1.png", check if a suffixed version exists (e.g., "1_YS.png")
                // and ALWAYS prefer the suffixed version if available (even if config says "1.png")
                if (selectedBgImage && selectedBgImage.trim() !== '') {
                    // Check if this is a plain "1.png" type file (not already suffixed)
                    const isPlainOnePng = /^1\.(png|jpg|jpeg|gif|svg)$/i.test(selectedBgImage);
                    if (isPlainOnePng) {
                        // Config has "1.png" - try to find suffixed version
                        const imageExtensions = ['png', 'jpg', 'jpeg', 'gif'];
                        const commonSuffixes = ['_YS', '_YS1', '_1'];
                        for (const suffix of commonSuffixes) {
                            for (const ext of imageExtensions) {
                                const suffixedFile = `1${suffix}.${ext}`;
                                try {
                                    const testResponse = await fetch(`./${suffixedFile}`);
                                    if (testResponse.ok) {
                                        selectedBgImage = suffixedFile; // ALWAYS prefer suffixed version
                                        break;
                                    }
                                } catch (e) {
                                    // Continue trying
                                }
                            }
                            if (selectedBgImage !== '1.png' && selectedBgImage !== '1.jpg') break;
                        }
                    }
                }

                // Fallback: Try to find 1*.png files (prioritize suffixed versions)
                if (!selectedBgImage || selectedBgImage.trim() === '') {
                    try {
                        // Try common patterns - suffixed versions first
                        const commonFiles = ['1_YS.png', '1_YS.jpg', '1.png', '1.jpg'];
                        for (const file of commonFiles) {
                            const testResponse = await fetch(`./${file}`);
                            if (testResponse.ok) {
                                selectedBgImage = file;
                                break;
                            }
                        }
                    } catch (e) {
                        // Ignore errors
                    }
                }

                // Get button background color
                let buttonBgColor = menuConfig.menuBackgroundColor ||
                    dialogConfig.dialogBackgroundColor ||
                    itemConfig.itemBackgroundColor ||
                    '#667eea';

                // Get button text color - prioritize itemSelectedTextColor (matches selected background)
                let buttonTextColor = itemConfig.itemSelectedTextColor ||
                    menuConfig.menuItemSelectedTextColor ||
                    dialogConfig.dialogOptionSelectedTextColor ||
                    '#ffffff';

                // Normalize color format (ensure # prefix if it's a hex color)
                if (buttonTextColor && !buttonTextColor.startsWith('#')) {
                    // If it's a 6-digit hex without #, add it
                    if (/^[0-9A-Fa-f]{6}$/.test(buttonTextColor)) {
                        buttonTextColor = '#' + buttonTextColor;
                    }
                }

                // Get arrow icon - use itemRightArrow from config.json (unified approach)
                // Then try *RightArrow*.* pattern, then common patterns
                let arrowIconFile = itemConfig.itemRightArrow || null;

                // If not in config, try *RightArrow*.* pattern (works for themes like Naruto)
                if (!arrowIconFile || arrowIconFile.trim() === '') {
                    try {
                        // Try GitHub API to find *RightArrow*.* files
                        const folderName = getFolderName();
                        const apiUrl = `https://api.github.com/repos/y1-community/InnioasisY1Themes/contents/${encodeURIComponent(folderName)}`;
                        const response = await fetch(apiUrl);
                        if (response.ok) {
                            const files = await response.json();
                            const rightArrowFiles = files
                                .filter(f => f.type === 'file' && /RightArrow/i.test(f.name) && /\.(png|jpg|jpeg|gif|svg)$/i.test(f.name))
                                .map(f => f.name);
                            if (rightArrowFiles.length > 0) {
                                arrowIconFile = rightArrowFiles[0];
                            }
                        }
                    } catch (e) {
                        // API not available, continue to common patterns
                    }
                }

                // If still not found, try common patterns
                if (!arrowIconFile || arrowIconFile.trim() === '') {
                    const commonArrowFiles = ['2_YS.png', '2_YS.jpg', '2.png', '2.jpg'];
                    for (const file of commonArrowFiles) {
                        try {
                            const testResponse = await fetch(`./${file}`);
                            if (testResponse.ok) {
                                arrowIconFile = file;
                                break;
                            }
                        } catch (e) {
                            // Continue trying
                        }
                    }
                }

                // Build button style
                let buttonBgStyle = '';
                if (selectedBgImage && selectedBgImage.trim() !== '') {
                    buttonBgStyle = `background-color: ${buttonBgColor}; background-image: url('./${selectedBgImage}'); background-size: 100% 100%; background-repeat: no-repeat; background-position: center;`;
                } else {
                    buttonBgStyle = `background-color: ${buttonBgColor};`;
                }

                const buttonStyle = `${buttonBgStyle} color: ${buttonTextColor}; ${fontStyle} text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5), 0 0 2px rgba(0, 0, 0, 0.8);`;

                // Apply to all buttons (install and download)
                const buttons = document.querySelectorAll('.btn.install, .btn.download');
                buttons.forEach(btn => {
                    // Apply button style (background, color, font, text shadow)
                    // Preserve existing display/flex properties, only override background/color/font/text-shadow
                    const existingStyle = btn.getAttribute('style') || '';
                    // Remove old background, color, font-family, and text-shadow from existing style
                    const cleanedStyle = existingStyle
                        .replace(/background[^;]*;?/gi, '')
                        .replace(/color[^;]*;?/gi, '')
                        .replace(/font-family[^;]*;?/gi, '')
                        .replace(/text-shadow[^;]*;?/gi, '')
                        .trim();
                    // Combine new theme styles with preserved styles
                    btn.setAttribute('style', buttonStyle + (cleanedStyle ? '; ' + cleanedStyle : ''));

                    // Also apply font to button text span
                    const textSpan = btn.querySelector('span span');
                    if (textSpan && themeFont) {
                        textSpan.style.fontFamily = `'${themeFont}', sans-serif`;
                    }

                    // Add arrow icon if available
                    if (arrowIconFile && arrowIconFile.trim() !== '') {
                        const existingArrow = btn.querySelector('.arrow-icon');
                        if (!existingArrow) {
                            const arrowSpan = document.createElement('span');
                            arrowSpan.className = 'arrow-icon';
                            const arrowImg = document.createElement('img');
                            arrowImg.src = `./${arrowIconFile}`;
                            arrowImg.alt = '‚Üí';
                            arrowImg.style.cssText = 'height: 100%; max-height: 100%; width: auto; flex-shrink: 0; object-fit: contain; display: block; position: relative; z-index: 3;';
                            arrowSpan.appendChild(arrowImg);

                            // Find the inner span (flex container) and add arrow to it
                            // Structure should be: btn > span (flex container) > span (text) + span (arrow-icon)
                            const flexContainer = btn.querySelector('span');
                            if (flexContainer) {
                                // Add arrow to the flex container (same level as text span)
                                flexContainer.appendChild(arrowSpan);
                            } else {
                                // Fallback: add directly to button
                                btn.appendChild(arrowSpan);
                            }
                        }
                    }
                });
            } catch (error) {
                console.warn('Could not apply theme button styling:', error);
            }
        }

        // Dynamic Data Loading
        // IMPORTANT: This page loads information programmatically from:
        // 1. config.json (in this theme's folder) - AUTHORITATIVE SOURCE
        // 2. themes.json (in parent directory) - FAST CACHE/FALLBACK  
        // 3. Hardcoded HTML values - LAST RESORT ONLY
        // This allows users to copy this index.html to another theme without editing it.
        document.addEventListener('DOMContentLoaded', async () => {
            const folderName = getFolderName();

            // Check for File System Access API support (works on Chrome desktop and Android)
            if ('showDirectoryPicker' in window) {
                document.getElementById('install-btn').style.display = 'inline-block';
                // Hide full download button, show small link
                document.getElementById('download-btn-full').style.display = 'none';
                document.getElementById('download-link-small').style.display = 'inline';

                // Detect Android and update install instructions
                const isAndroid = /Android/i.test(navigator.userAgent);
                const androidStep = document.getElementById('android-step');
                const desktopStep = document.getElementById('desktop-step');

                if (isAndroid && androidStep && desktopStep) {
                    androidStep.style.display = 'list-item';
                    desktopStep.style.display = 'none';
                } else if (androidStep && desktopStep) {
                    androidStep.style.display = 'none';
                    desktopStep.style.display = 'list-item';
                }
            }

            // Apply theme button styling
            await applyThemeButtonStyling();

            // Add touch event handlers for mobile to show arrow when button is held
            const buttons = document.querySelectorAll('.btn.install, .btn.download');
            buttons.forEach(btn => {
                btn.addEventListener('touchstart', function () {
                    this.classList.add('touching');
                });
                btn.addEventListener('touchend', function () {
                    this.classList.remove('touching');
                });
                btn.addEventListener('touchcancel', function () {
                    this.classList.remove('touching');
                });
            });

            // Check for unsupported features
            await checkFeatureSupport();

            // Load and update author information with authorUrl link
            await loadAuthorInfo();
        });

        // Helper function to get GitHub raw URL for faster CDN loading
        function getGitHubRawUrl(filename) {
            const folderName = getFolderName();
            return `https://raw.githubusercontent.com/y1-community/InnioasisY1Themes/main/${encodeURIComponent(folderName)}/${encodeURIComponent(filename)}`;
        }

        // Helper function to get local URL (fallback)
        function getLocalUrl(filename) {
            return `./${encodeURIComponent(filename)}`;
        }

        // Helper function to check if a PNG image is fully transparent
        async function isFullyTransparent(imageUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';

                img.onload = function () {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        // Check if all pixels are fully transparent (alpha = 0)
                        for (let i = 3; i < data.length; i += 4) {
                            if (data[i] !== 0) {
                                // Found at least one non-transparent pixel
                                resolve(false);
                                return;
                            }
                        }

                        // All pixels are fully transparent
                        resolve(true);
                    } catch (e) {
                        // If we can't analyze, assume not fully transparent
                        resolve(false);
                    }
                };

                img.onerror = function () {
                    resolve(false);
                };

                img.src = imageUrl;
            });
        }

        // Helper function to load image with GitHub raw URL as primary source, local as fallback
        async function loadImageWithFallback(filename, preferGitHub = true) {
            if (preferGitHub) {
                // Try GitHub raw URL first (faster CDN)
                const githubUrl = getGitHubRawUrl(filename);
                try {
                    const response = await fetch(githubUrl, { method: 'HEAD' });
                    if (response.ok) {
                        return githubUrl;
                    }
                } catch (e) {
                    // Fallback to local
                }
            }

            // Fallback to local URL
            const localUrl = getLocalUrl(filename);
            try {
                const response = await fetch(localUrl, { method: 'HEAD' });
                if (response.ok) {
                    return localUrl;
                }
            } catch (e) {
                // Not found
            }

            return null;
        }

        // Load cover image using wildcard *cover*.* pattern with format prioritization (GIF > JPG > PNG)
        async function loadCoverImage(themeTitle) {
            const coverImage = document.getElementById('cover-image');
            if (!coverImage) return;

            const folderName = getFolderName();
            let coverFiles = [];

            // Strategy 1: Try GitHub API to get file list
            try {
                const apiUrl = `https://api.github.com/repos/y1-community/InnioasisY1Themes/contents/${encodeURIComponent(folderName)}`;
                const response = await fetch(apiUrl);
                if (response.ok) {
                    const files = await response.json();
                    // Filter for *cover*.* pattern (case-insensitive)
                    const allCoverFiles = files
                        .filter(file => file.type === 'file' &&
                            /\.(gif|jpg|jpeg|png)$/i.test(file.name) &&
                            /cover/i.test(file.name))
                        .map(file => file.name);

                    // Deduplicate: If multiple formats exist for same base name, keep only the best one
                    // Priority: GIF > JPG/JPEG > PNG
                    const fileMap = new Map(); // base name -> best format
                    const extensionPriority = { 'gif': 1, 'jpg': 2, 'jpeg': 2, 'png': 3 };

                    allCoverFiles.forEach(filename => {
                        const ext = filename.split('.').pop().toLowerCase();
                        const baseName = filename.substring(0, filename.lastIndexOf('.'));
                        const priority = extensionPriority[ext] || 99;

                        if (!fileMap.has(baseName) || priority < fileMap.get(baseName).priority) {
                            fileMap.set(baseName, { filename, priority });
                        }
                    });

                    coverFiles = Array.from(fileMap.values()).map(item => item.filename);
                }
            } catch (apiError) {
                console.log('GitHub API not available for cover, using pattern discovery');
            }

            // Strategy 2: If API didn't work, try common cover patterns with format prioritization
            if (coverFiles.length === 0) {
                // Try wildcard patterns with format prioritization (GIF > JPG > PNG)
                const coverBases = [
                    'cover', 'gregcover', 'cover_noscale', 'cover_WS', 'cover_YS',
                    '@Be_cover', '@Cup_cover', '@Pris_cover'
                ];
                const extensions = ['gif', 'jpg', 'jpeg', 'png']; // Priority order

                // Test each base with each extension, in priority order
                for (const base of coverBases) {
                    for (const ext of extensions) {
                        const pattern = `${base}.${ext}`;
                        // Try GitHub raw URL first (faster), then fallback to local
                        const githubUrl = getGitHubRawUrl(pattern);
                        const localPattern = `./${encodeURIComponent(pattern)}`;

                        try {
                            let response = await fetch(githubUrl, { method: 'HEAD' });
                            if (!response.ok) {
                                response = await fetch(localPattern, { method: 'HEAD' });
                            }
                            if (response.ok) {
                                coverFiles.push(pattern);
                                break; // Found best format for this base, move to next base
                            }
                        } catch (e) {
                            // Continue trying
                        }
                    }
                }
            }

            // Final sort by extension priority: GIF > JPG > PNG
            if (coverFiles.length > 0) {
                const extensionPriority = { 'gif': 1, 'jpg': 2, 'jpeg': 2, 'png': 3 };
                coverFiles.sort((a, b) => {
                    const extA = a.split('.').pop().toLowerCase();
                    const extB = b.split('.').pop().toLowerCase();
                    const priorityA = extensionPriority[extA] || 99;
                    const priorityB = extensionPriority[extB] || 99;
                    return priorityA - priorityB;
                });

                const coverFile = coverFiles[0];
                // Try GitHub raw URL first (faster CDN), then fallback to local
                const githubUrl = getGitHubRawUrl(coverFile);
                const localUrl = getLocalUrl(coverFile);

                // Try GitHub first, then fallback to local if it fails
                coverImage.src = githubUrl;
                coverImage.alt = `${themeTitle || 'Theme'} cover`;
                coverImage.onclick = () => openLightbox(githubUrl, coverFile);

                // Handle image load error - fallback to local URL
                coverImage.onerror = function () {
                    this.src = localUrl;
                    this.onclick = () => openLightbox(localUrl, coverFile);
                    // If local also fails, hide the image
                    this.onerror = function () {
                        this.style.display = 'none';
                    };
                };

                // Show image once loaded successfully
                coverImage.onload = function () {
                    this.style.display = 'block';
                };
            } else {
                // No cover image found - hide it
                coverImage.style.display = 'none';
            }
        }

        // Load theme information from config.json (priority) or themes.json (fallback)
        async function loadAuthorInfo() {
            try {
                // Get folder name from URL
                const folderName = getFolderName();

                // Initialize values - folder name as fallback for title
                let title = folderName || 'Theme';
                let author = null;
                let authorUrl = null;
                let description = null;

                // Try to load from config.json first (authoritative source)
                let configExists = false;
                try {
                    const configResponse = await fetch('./config.json');
                    if (configResponse.ok) {
                        configExists = true;
                        const config = await configResponse.json();

                        // Check theme_info structure first (new format)
                        if (config.theme_info) {
                            if (config.theme_info.title) title = config.theme_info.title;
                            if (config.theme_info.author) author = config.theme_info.author;
                            if (config.theme_info.authorUrl) authorUrl = config.theme_info.authorUrl;
                            if (config.theme_info.description) description = config.theme_info.description;
                        }

                        // Fallback to direct properties (old format, backwards compatibility)
                        if (!author && config.author) author = config.author;
                        if (!authorUrl && config.authorUrl) authorUrl = config.authorUrl;
                        if (!description && config.description) description = config.description;
                        if (!title || title === folderName) {
                            if (config.title) title = config.title;
                            if (config.name) title = config.name;
                        }
                    } else if (configResponse.status === 404) {
                        configExists = false;
                    }
                } catch (e) {
                    console.warn('Could not load config.json:', e);
                    configExists = false;
                }

                // Show error message if config.json doesn't exist
                if (!configExists) {
                    const container = document.querySelector('.container');
                    if (container) {
                        const errorDiv = document.createElement('div');
                        errorDiv.id = 'config-missing-warning';
                        errorDiv.style.cssText = 'background: #fff3cd; border: 2px solid #ff9800; border-radius: 8px; padding: 20px; margin-bottom: 30px; color: #856404;';
                        errorDiv.innerHTML = `
                            <h3 style="color: #ff9800; margin-top: 0; margin-bottom: 15px;">‚ö†Ô∏è config.json File Missing</h3>
                            <p style="margin-bottom: 15px; line-height: 1.6;">
                                This theme page requires a <code style="background: rgba(255, 152, 0, 0.1); padding: 2px 6px; border-radius: 3px; font-family: monospace;">config.json</code> file in the theme folder to display theme information, assets, and screenshots.
                            </p>
                            <p style="margin-bottom: 15px; line-height: 1.6;">
                                <strong>Theme creators:</strong> Please download the latest <code style="background: rgba(255, 152, 0, 0.1); padding: 2px 6px; border-radius: 3px; font-family: monospace;">index.html</code> file from the <a href="https://themes.innioasis.app/yourTheme/" target="_blank" style="color: #667eea; text-decoration: underline; font-weight: 600;">yourTheme directory</a> and place it in your theme folder before uploading to the repository.
                            </p>
                            <p style="margin-top: 20px; margin-bottom: 0;">
                                <a href="https://raw.githubusercontent.com/y1-community/InnioasisY1Themes/main/yourTheme/index.html" download="index.html" target="_blank" style="display: inline-block; background: #667eea; color: white; padding: 10px 20px; border-radius: 6px; text-decoration: none; font-weight: 600; margin-right: 10px;">üì• Download index.html Template</a>
                                <a href="https://github.com/y1-community/InnioasisY1Themes" target="_blank" style="color: #667eea; text-decoration: underline;">Learn more on GitHub ‚Üí</a>
                            </p>
                        `;
                        container.insertBefore(errorDiv, container.firstChild);
                    }
                }

                // Fallback to themes.json
                try {
                    const themesResponse = await fetch('../themes.json');
                    if (themesResponse.ok) {
                        const themesData = await themesResponse.json();
                        const theme = themesData.themes.find(t => t.folder === folderName);

                        if (theme) {
                            // Only use values from themes.json if not already loaded from config.json
                            if (!title || title === folderName) {
                                if (theme.name) title = theme.name;
                            }
                            if (!author && theme.author) author = theme.author;
                            if (!authorUrl && theme.authorUrl) authorUrl = theme.authorUrl;
                            if (!description && theme.description) description = theme.description;
                        }
                    }
                } catch (e) {
                    console.warn('Could not load themes.json:', e);
                }

                // Final fallback: use folder name for title if still not set
                if (!title || title === folderName) {
                    title = folderName || 'Theme';
                }

                // Update title - replace loading placeholder
                const titleElement = document.getElementById('theme-title');
                if (titleElement) {
                    titleElement.innerHTML = `About the ${title} Theme for Innioasis Y1`;
                    titleElement.style.transition = 'opacity 0.3s ease-in';
                }

                // Update description (top section) - replace loading placeholder
                const themeDescriptionElement = document.getElementById('theme-description');
                if (themeDescriptionElement) {
                    if (description) {
                        themeDescriptionElement.innerHTML = description;
                        themeDescriptionElement.style.transition = 'opacity 0.3s ease-in';
                    } else {
                        themeDescriptionElement.innerHTML = '';
                        themeDescriptionElement.style.display = 'none';
                    }
                }

                // Update description (bottom section - SEO) - replace loading placeholder
                const descriptionDisplay = document.getElementById('description-display');
                if (descriptionDisplay) {
                    if (description) {
                        descriptionDisplay.innerHTML = description;
                        descriptionDisplay.style.transition = 'opacity 0.3s ease-in';
                    } else {
                        descriptionDisplay.innerHTML = '';
                        descriptionDisplay.style.display = 'none';
                    }
                }

                // Update author display with link if authorUrl is available
                const authorDisplay = document.getElementById('author-display');

                if (authorDisplay) {
                    // Use author if available, otherwise hide
                    if (author) {
                        // Detect Reddit username (u/username pattern)
                        const redditUsernameMatch = author.match(/u\/([^\/\s]+)/i);
                        let redditUsername = null;
                        let redditFaviconHtml = '';

                        if (redditUsernameMatch) {
                            redditUsername = redditUsernameMatch[1];
                            // Create Reddit favicon that links to reddit.com/user/username
                            redditFaviconHtml = `<a href="https://reddit.com/user/${redditUsername}" target="_blank" rel="noopener noreferrer" class="reddit-favicon" onclick="event.stopPropagation();" style="display: inline-block; width: 16px; height: 16px; margin-left: 4px; vertical-align: middle; opacity: 0.8; transition: opacity 0.2s;"><img src="https://www.redditstatic.com/desktop2x/img/favicon/favicon-16x16.png" alt="Reddit" style="width: 100%; height: 100%; object-fit: contain;"></a>`;
                        }

                        if (authorUrl) {
                            // Author name links to authorUrl, Reddit favicon links to Reddit profile
                            authorDisplay.innerHTML = `<a href="${authorUrl}" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: none; border-bottom: 1px solid #667eea; transition: all 0.2s;">${author}</a>${redditFaviconHtml}`;
                            // Add hover effect
                            const authorLink = authorDisplay.querySelector('a:not(.reddit-favicon)');
                            if (authorLink) {
                                authorLink.addEventListener('mouseenter', function () {
                                    this.style.color = '#764ba2';
                                    this.style.borderBottomColor = '#764ba2';
                                });
                                authorLink.addEventListener('mouseleave', function () {
                                    this.style.color = '#667eea';
                                    this.style.borderBottomColor = '#667eea';
                                });
                            }
                        } else {
                            // No authorUrl - just display author name with Reddit favicon if detected
                            authorDisplay.innerHTML = `${author}${redditFaviconHtml}`;
                        }
                        authorDisplay.style.visibility = 'visible';
                    } else {
                        authorDisplay.style.visibility = 'hidden';
                    }
                }

                // Update meta tags and structured data
                const pageTitle = `${title} Theme - Official Innioasis Y1 Community Themes`;
                const metaDescription = description ?
                    `Download ${title} theme for Innioasis Y1 MP3 player. Official community theme repository endorsed by Innioasis. ${description} Community Maintainers: Ryan Specter + Dmitri Medina` :
                    `Download ${title} theme for Innioasis Y1 MP3 player. Official community theme repository endorsed by Innioasis. Community Maintainers: Ryan Specter + Dmitri Medina`;

                // Update page title
                document.title = pageTitle;

                // Update meta description
                let metaDescTag = document.querySelector('meta[name="description"]');
                if (!metaDescTag) {
                    metaDescTag = document.createElement('meta');
                    metaDescTag.name = 'description';
                    document.head.appendChild(metaDescTag);
                }
                metaDescTag.content = metaDescription;

                // Update meta keywords
                let metaKeywordsTag = document.querySelector('meta[name="keywords"]');
                if (!metaKeywordsTag) {
                    metaKeywordsTag = document.createElement('meta');
                    metaKeywordsTag.name = 'keywords';
                    document.head.appendChild(metaKeywordsTag);
                }
                metaKeywordsTag.content = `Innioasis Y1, Y1 themes, MP3 player themes, ${title}, Y1 customization, official Y1 themes, Ryan Specter, Dmitri Medina`;

                // Update structured data
                let structuredDataScript = document.querySelector('script[type="application/ld+json"]');
                if (structuredDataScript) {
                    try {
                        const structuredData = {
                            "@context": "https://schema.org",
                            "@type": "SoftwareApplication",
                            "name": `${title} Theme`,
                            "applicationCategory": "Theme",
                            "operatingSystem": "Innioasis Y1",
                            "description": metaDescription,
                            "url": `https://themes.innioasis.app/${encodeURIComponent(folderName)}/`,
                            "publisher": {
                                "@type": "Organization",
                                "name": "Innioasis Y1 Community",
                                "url": "https://themes.innioasis.app"
                            },
                            "maintainer": [
                                {
                                    "@type": "Person",
                                    "name": "Ryan Specter",
                                    "url": "https://ryanspecter.uk"
                                },
                                {
                                    "@type": "Person",
                                    "name": "Dmitri Medina",
                                    "url": "https://reddit.com/user/dmitrimedina"
                                }
                            ]
                        };
                        structuredDataScript.textContent = JSON.stringify(structuredData);
                    } catch (e) {
                        console.warn('Could not update structured data:', e);
                    }
                }

                // Update edit link
                const editLink = document.getElementById('edit-theme-link');
                if (editLink) {
                    editLink.href = `https://github.com/y1-community/InnioasisY1Themes/tree/main/${encodeURIComponent(folderName)}#readme`;
                }

                // Load cover image dynamically with wildcard pattern
                await loadCoverImage(title);

            } catch (error) {
                console.warn('Could not load theme information:', error);
                // Show folder name as fallback
                const titleElement = document.getElementById('theme-title');
                if (titleElement) {
                    const folderName = getFolderName();
                    titleElement.textContent = `About the ${folderName || 'Theme'} Theme for Innioasis Y1`;
                    titleElement.style.visibility = 'visible';
                }
            }
        }

        // Check which features are not supported by this theme
        async function checkFeatureSupport() {
            try {
                const configResponse = await fetch('./config.json');
                if (!configResponse.ok) return;

                const config = await configResponse.json();

                // Define all possible features that should be checked
                // Based on MelodyMuncher's complete config.json (100% spec usage)
                // Format: { key: 'configKey', displayName: 'Display Name', section: 'homePageConfig' | 'settingConfig' }
                // For self-explanatory features (like "backlight_60"), displayName is the key itself
                // For features needing explanation, provide a friendly displayName
                // Only check the 4 specific upcoming/region-specific features
                // Note: ebook, calculator, calendar are in homePageConfig in MelodyMuncher
                // launcher is in settingConfig
                const upcomingFeaturesToCheck = [
                    { key: 'ebook', displayName: 'E-book Reader', section: 'homePageConfig', configKey: 'ebook', imageFile: 'ebook.png' },
                    { key: 'calculator', displayName: 'Calculator', section: 'homePageConfig', configKey: 'calculator', imageFile: 'calculator.png' },
                    { key: 'calendar', displayName: 'Calendar', section: 'homePageConfig', configKey: 'calendar', imageFile: 'calendar.png' },
                    { key: 'launcher', displayName: 'Rockbox / Alternative Launcher Icon', section: 'settingConfig', configKey: 'launcher', imageFile: 'Launcher.png' }
                ];

                const unsupportedFeatures = [];

                // Check each upcoming feature
                for (const feature of upcomingFeaturesToCheck) {
                    const section = config[feature.section] || {};
                    const featureValue = section[feature.key];

                    // Feature is unsupported if:
                    // 1. The key doesn't exist in the section
                    // 2. The value is empty string
                    // 3. The value is null or undefined
                    // 4. The value is not a string (should be a string with filename)
                    if (!featureValue ||
                        (typeof featureValue === 'string' && featureValue.trim() === '') ||
                        typeof featureValue !== 'string') {
                        unsupportedFeatures.push(feature);
                    }
                }

                // Display unsupported features if any
                if (unsupportedFeatures.length > 0) {
                    const section = document.getElementById('feature-support-section');
                    const list = document.getElementById('unsupported-features-list');

                    if (section && list) {
                        list.innerHTML = unsupportedFeatures.map(feature => {
                            // Create GitHub link to the example image in MelodyMuncher
                            const exampleImageUrl = `https://github.com/y1-community/InnioasisY1Themes/blob/main/MelodyMuncher/${encodeURIComponent(feature.imageFile)}`;
                            const sectionName = feature.section === 'homePageConfig' ? 'homePageConfig' : 'settingConfig';
                            return `<li style="margin-bottom: 5px;"><a href="${exampleImageUrl}" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: none; border-bottom: 1px solid #667eea;">${feature.displayName}</a> - "${feature.configKey}" in "${sectionName}"</li>`;
                        }).join('');
                        section.style.display = 'block';
                    }
                }
            } catch (error) {
                console.warn('Could not check feature support:', error);
            }
        }

        // Show install instructions modal (skip if folder already selected on home page)
        function showInstallInstructions() {
            // Check if folder was already selected on home page
            const savedFolderHandle = localStorage.getItem('y1ThemesFolderHandle');
            if (savedFolderHandle) {
                // Folder already selected - skip dialog and proceed directly
                proceedWithInstall();
                return;
            }

            // Show dialog for first-time selection
            document.getElementById('install-modal').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        // Close install instructions modal
        function closeInstallModal() {
            document.getElementById('install-modal').classList.remove('active');
            document.body.style.overflow = 'auto';
        }

        // Proceed with installation after user confirms
        function proceedWithInstall() {
            closeInstallModal();
            // Now proceed with actual installation
            installTheme();
        }

        // Install Theme directly to device
        async function installTheme() {
            const folderName = getFolderName();
            const btn = document.getElementById('install-btn');
            const status = document.getElementById('download-status');

            // Get theme font for progress display
            const themeFont = await loadThemeFont();
            const fontStyle = themeFont ? `font-family: '${themeFont}', sans-serif;` : '';

            try {
                // Check if folder was already selected on home page (skip dialog if so)
                let dirHandle = null;
                const savedFolderHandle = localStorage.getItem('y1ThemesFolderHandle');

                if (!savedFolderHandle) {
                    // 1. Ask user to select Themes folder (modal already shown by showInstallInstructions)
                    status.style.display = 'block';
                    status.textContent = 'Please select the "Themes" folder on your Y1 device...';

                    dirHandle = await window.showDirectoryPicker({
                        mode: 'readwrite',
                        startIn: 'downloads'
                    });
                } else {
                    // Folder already selected on home page - skip dialog and use saved handle
                    // Note: We can't actually restore the handle from localStorage (security restriction)
                    // So we still need to ask, but we can skip the preparation dialog
                    status.style.display = 'block';
                    status.textContent = 'Please select the "Themes" folder on your Y1 device...';

                    dirHandle = await window.showDirectoryPicker({
                        mode: 'readwrite',
                        startIn: 'downloads'
                    });
                }

                // Verify it's likely the right folder (optional, but good UX)
                if (dirHandle.name !== 'Themes' && dirHandle.name !== 'themes') {
                    if (!confirm(`You selected "${dirHandle.name}", but usually this should be the "Themes" folder. Continue?`)) {
                        status.textContent = 'Installation cancelled.';
                        return;
                    }
                }

                btn.disabled = true;
                btn.textContent = '‚è≥ Installing...';
                if (fontStyle) {
                    btn.style.fontFamily = themeFont ? `'${themeFont}', sans-serif` : '';
                }
                status.textContent = 'Fetching file list...';

                // 2. Get all files from GitHub (recursive - handles subdirectories)
                async function getAllFilesRecursive(path = folderName, basePath = '') {
                    const apiUrl = `https://api.github.com/repos/y1-community/InnioasisY1Themes/contents/${path}`;
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        console.warn(`Failed to fetch ${path}, trying alternative method`);
                        return [];
                    }
                    const items = await response.json();
                    const allFiles = [];

                    for (const item of items) {
                        if (item.type === 'file') {
                            allFiles.push({
                                name: basePath ? `${basePath}/${item.name}` : item.name,
                                download_url: item.download_url,
                                path: item.path
                            });
                        } else if (item.type === 'dir') {
                            // Recursively get files from subdirectories
                            const subPath = item.path;
                            const subBasePath = basePath ? `${basePath}/${item.name}` : item.name;
                            const subFiles = await getAllFilesRecursive(subPath, subBasePath);
                            allFiles.push(...subFiles);
                        }
                    }

                    return allFiles;
                }

                const allFiles = await getAllFilesRecursive();

                if (allFiles.length === 0) {
                    throw new Error('No files found. The theme may be empty or the repository structure has changed.');
                }

                // 3. Create theme folder on device
                const themeDir = await dirHandle.getDirectoryHandle(folderName, { create: true });

                let processed = 0;
                const total = allFiles.length;

                // 4. Download and write each file (handles nested paths)
                // Show progress: downloading files before installation (in theme font)
                status.textContent = `Downloading files (0/${total})...`;
                btn.textContent = `‚è≥ Downloading files...`;
                if (fontStyle) {
                    btn.style.fontFamily = themeFont ? `'${themeFont}', sans-serif` : '';
                }

                for (const file of allFiles) {
                    const fileName = file.name.split('/').pop(); // Get just filename for display
                    status.textContent = `Downloading ${fileName} (${processed + 1}/${total})...`;
                    btn.textContent = `‚è≥ Downloading ${processed + 1}/${total}...`;
                    if (fontStyle) {
                        btn.style.fontFamily = themeFont ? `'${themeFont}', sans-serif` : '';
                    }

                    let blob;

                    // Check cache first (images loaded in gallery are already cached)
                    const cachedFile = fileCache.get(fileName);
                    if (cachedFile) {
                        blob = cachedFile.blob;
                        console.log(`‚úÖ Using cached file: ${fileName}`);
                    } else {
                        // Fetch from network if not cached
                        const fileResponse = await fetch(file.download_url);
                        if (!fileResponse.ok) {
                            console.warn(`Failed to fetch ${file.name}, skipping...`);
                            continue;
                        }
                        blob = await fileResponse.blob();

                        // Cache it for future use
                        const arrayBuffer = await blob.arrayBuffer();
                        fileCache.set(fileName, {
                            blob: blob,
                            arrayBuffer: arrayBuffer,
                            url: file.download_url
                        });
                    }

                    processed++;
                }

                // 5. Now install files to device
                status.textContent = `Installing files (0/${total})...`;
                btn.textContent = `‚è≥ Installing files...`;
                if (fontStyle) {
                    btn.style.fontFamily = themeFont ? `'${themeFont}', sans-serif` : '';
                }
                processed = 0;

                for (const file of allFiles) {
                    const fileName = file.name.split('/').pop();
                    status.textContent = `Installing ${fileName} (${processed + 1}/${total})...`;
                    btn.textContent = `‚è≥ Installing ${processed + 1}/${total}...`;
                    if (fontStyle) {
                        btn.style.fontFamily = themeFont ? `'${themeFont}', sans-serif` : '';
                    }

                    // Handle nested paths - create subdirectories if needed
                    const pathParts = file.name.split('/');
                    let currentDir = themeDir;

                    // Create subdirectories if file is in a subdirectory
                    for (let i = 0; i < pathParts.length - 1; i++) {
                        currentDir = await currentDir.getDirectoryHandle(pathParts[i], { create: true });
                    }

                    const finalFileName = pathParts[pathParts.length - 1];

                    // Get blob from cache or fetch
                    let blob;
                    const cachedFile = fileCache.get(finalFileName);
                    if (cachedFile) {
                        blob = cachedFile.blob;
                    } else {
                        // Shouldn't happen if we downloaded above, but fallback
                        const fileResponse = await fetch(file.download_url);
                        if (!fileResponse.ok) {
                            console.warn(`Failed to fetch ${file.name}, skipping...`);
                            continue;
                        }
                        blob = await fileResponse.blob();
                    }

                    // Write to device
                    const fileHandle = await currentDir.getFileHandle(finalFileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();

                    processed++;
                }

                btn.textContent = '‚úÖ Installed!';
                status.textContent = 'Theme installed successfully! You can now disconnect your device.';
                setTimeout(() => {
                    btn.disabled = false;
                    btn.textContent = 'üöÄ Install on Y1';
                }, 3000);

            } catch (error) {
                console.error('Installation error:', error);
                if (error.name === 'AbortError') {
                    status.textContent = 'Installation cancelled.';
                } else {
                    status.textContent = 'Installation failed: ' + error.message;
                    alert('Installation failed. Please try downloading the ZIP instead.');
                }
                btn.disabled = false;
                btn.textContent = 'üöÄ Install on Y1';
            }
        }

        // Download theme as ZIP
        async function downloadTheme() {
            const folderName = getFolderName();
            const themeName = folderName;
            const btn = document.getElementById('download-btn-full');
            const status = document.getElementById('download-status');

            btn.disabled = true;
            btn.textContent = '‚è≥ Downloading...';
            status.style.display = 'block';
            status.textContent = 'Fetching file list...';

            try {
                const zip = new JSZip();
                // Create a folder inside the zip with the theme name
                const themeFolder = zip.folder(folderName);

                // Get all files from the current directory (hosted site)
                async function getAllFilesRecursive(path = '', basePath = '') {
                    const fullPath = path ? `../${folderName}/${path}` : `../${folderName}`;

                    // Try to fetch the directory listing from the server
                    // Since we're on GitHub Pages, we need to manually list known files
                    // We'll use a different approach: fetch config.json to get file patterns
                    const allFiles = [];

                    // Common theme files that should be included
                    const commonFiles = [
                        'config.json',
                        'index.html',
                        'README.md',
                        'init.txt'
                    ];

                    // Common image patterns
                    const imagePatterns = [
                        'screenshot.jpg', 'screenshot.jpeg', 'screenshot.png', 'screenshot.gif',
                        'screenshot2.jpg', 'screenshot2.jpeg', 'screenshot2.png', 'screenshot2.gif',
                        'screenshot3.jpg', 'screenshot3.jpeg', 'screenshot3.png', 'screenshot3.gif',
                        'screenshot4.jpg', 'screenshot4.jpeg', 'screenshot4.png', 'screenshot4.gif',
                        'cover.jpg', 'cover.jpeg', 'cover.png', 'cover.gif',
                        'Cover.jpg', 'Cover.jpeg', 'Cover.PNG', 'Cover.gif',
                        'gregcover.png', 'cover_WS.png', 'cover_YS.png',
                        'desk.png', 'desk.jpg', 'desk.gif',
                        'desk_bg001.png', 'global_bg001.png',
                        'download.gif', 'download.jpg',
                        '1.png', '2.png', '3.png', '4.png',
                        'transparent.png', 'mask.png', 'setting_mask.png',
                        'pause.png', 'play.png', 'stop.png', 'playing.png'
                    ];

                    // Menu icons
                    const menuIcons = [
                        'Music.png', 'Videos.png', 'Photos.png', 'Audiobooks.png',
                        'FM Radio.png', 'Bluetooth.png', 'Settings.png', 'Now Playing.png',
                        'Launcher.png', 'Shuffle Quick.png'
                    ];

                    // Battery icons
                    const batteryIcons = [
                        'battery.001.png', 'battery.002.png', 'battery.003.png', 'battery.004.png',
                        'battery_001.png', 'battery_002.png', 'battery_003.png', 'battery_004.png',
                        'Battery1.png', 'Battery2.png', 'Battery3.png', 'Battery4.png',
                        'batterycharge.001.png', 'batterycharge.002.png', 'batterycharge.003.png', 'batterycharge.004.png',
                        'batterycharge_001.png', 'batterycharge_002.png', 'batterycharge_003.png', 'batterycharge_004.png',
                        'BatteryCharge1.png', 'BatteryCharge2.png', 'BatteryCharge3.png', 'BatteryCharge4.png'
                    ];

                    // Settings icons
                    const settingsIcons = [
                        'Backlight_001@1x.png', 'Backlight_002@1x.png', 'Backlight_003@1x.png', 'Backlight_004@1x.png',
                        'Backlight_005@1x.png', 'Backlight_006@1x.png', 'Backlight_007@1x.png', 'Backlight_008@1x.png',
                        'Brightness@1x.png', 'Change Theme@1x.png', 'Clear cache@1x.png', 'Date & Time@1x.png',
                        'Display battery_off@1x.png', 'Display battery_on@1x.png',
                        'Equalizer_classical@1x.png', 'Equalizer_dance@1x.png', 'Equalizer_flat@1x.png',
                        'Equalizer_folk@1x.png', 'Equalizer_heavy metal@1x.png', 'Equalizer_hiphop@1x.png',
                        'Equalizer_jazz@1x.png', 'Equalizer_normal@1x.png', 'Equalizer_pop@1x.png', 'Equalizer_rock@1x.png',
                        'Factory@1x.png', 'Key lock_off@1x.png', 'Key lock_on@1x.png',
                        'Key tone_off@1x.png', 'Key tone_on@1x.png',
                        'Key vibration_off@1x.png', 'Key vibration_on@1x.png',
                        'Language@1x.png', 'Repeat_all@1x.png', 'Repeat_off@1x.png', 'Repeat_one@1x.png',
                        'Shuffle_off@1x.png', 'Shuffle_on@1x.png', 'Shutdown@1x.png',
                        'Timed shutdown_001@1x.png', 'Timed shutdown_002@1x.png', 'Timed shutdown_003@1x.png',
                        'Timed shutdown_004@1x.png', 'Timed shutdown_005@1x.png', 'Timed shutdown_006@1x.png',
                        'Timed shutdown_007@1x.png', 'Wallpaper@1x.png', 'Wallpapper@1x.png',
                        'file_ext_off.png', 'file_ext_on.png'
                    ];

                    // Theme-specific files
                    const themeSpecificFiles = [
                        'RightArrow.png', 'ItemSelect.png', 'OptionSelect.png',
                        'Background1.png', 'Background2.png',
                        // Font files
                        'opensans-condbold.ttf', 'opensans-condlight.ttf', 'minecraft.ttf',
                        'Courier New Bold.ttf', 'Font.ttf',
                        // Additional theme files
                        'calculator.png', 'calendar.png', 'ebook.png', 'folder.png',
                        'music_file.png', 'audiobookPlaying.png', 'fmPlaying.png',
                        'blConnected.png', 'blConnecting.png', 'blDisconnected.png',
                        'headsetWithoutMic.png'
                    ];

                    // Theme-specific prefixed files
                    const prefixedPatterns = [
                        '@ThM_cover.png', '@ThM_icon.png', '@ThM_desktop_wallpaper.png', '@ThM_global_wallpaper.png',
                        '@ThM_Music.png', '@ThM_Videos.png', '@ThM_Photos.png', '@ThM_Audiobooks.png',
                        '@ThM_FM Radio.png', '@ThM_Bluetooth.png', '@ThM_Settings.png', '@ThM_Now Playing.png',
                        '@ThM_pause.png', '@ThM_play.png', '@ThM_stop.png',
                        '@ThM_itemBackground.png', '@ThM_itemBackgroundClear.png', '@ThM_itemRightArrow.png',
                        '@ThM_itemSelectedBackground.png', '@ThM_dialogOptionSelectedBackground.png',
                        '@ThM_setting_mask.png',
                        '@Be_cover.png', '@Cup_cover.png', '@Pris_cover.png'
                    ];

                    const allPatterns = [
                        ...commonFiles,
                        ...imagePatterns,
                        ...menuIcons,
                        ...batteryIcons,
                        ...settingsIcons,
                        ...themeSpecificFiles,
                        ...prefixedPatterns
                    ];

                    // Try to fetch each file
                    for (const fileName of allPatterns) {
                        const filePath = basePath ? `${basePath}/${fileName}` : fileName;
                        const fileUrl = `../${folderName}/${filePath}`;

                        try {
                            const response = await fetch(fileUrl, { method: 'HEAD' });
                            if (response.ok) {
                                allFiles.push({
                                    name: filePath,
                                    download_url: fileUrl,
                                    path: filePath
                                });
                            }
                        } catch (e) {
                            // File doesn't exist, continue
                        }
                    }

                    return allFiles;
                }

                const allFiles = await getAllFilesRecursive();

                if (allFiles.length === 0) {
                    throw new Error('No files found. The theme may be empty or inaccessible.');
                }

                let processed = 0;
                const total = allFiles.length;

                // Download each file (handles nested paths)
                // Show progress: downloading files before zip packing
                status.textContent = `Downloading files (0/${total})...`;
                btn.textContent = `‚è≥ Downloading ${0}/${total}...`;

                for (const file of allFiles) {
                    const fileName = file.name.split('/').pop(); // Get just filename for display
                    status.textContent = `Downloading ${fileName} (${processed + 1}/${total})...`;
                    btn.textContent = `‚è≥ Downloading ${processed + 1}/${total}...`;

                    try {
                        let arrayBuffer;

                        // Check cache first (images loaded in gallery are already cached)
                        const cachedFile = fileCache.get(fileName);
                        if (cachedFile) {
                            arrayBuffer = cachedFile.arrayBuffer;
                            console.log(`‚úÖ Using cached file: ${fileName}`);
                        } else {
                            // Fetch from network if not cached
                            const fileResponse = await fetch(file.download_url);
                            if (!fileResponse.ok) {
                                console.warn(`Failed to fetch ${file.name}, skipping...`);
                                continue;
                            }
                            const blob = await fileResponse.blob();
                            arrayBuffer = await blob.arrayBuffer();

                            // Cache it for future use
                            fileCache.set(fileName, {
                                blob: blob,
                                arrayBuffer: arrayBuffer,
                                url: file.download_url
                            });
                        }

                        // Handle nested paths in ZIP
                        const zipPath = file.name;
                        themeFolder.file(zipPath, arrayBuffer);
                        processed++;
                    } catch (err) {
                        console.warn(`Error downloading ${file.name}:`, err);
                        // Continue with other files
                    }
                }

                // Now pack into ZIP
                status.textContent = 'Packing files into ZIP...';
                btn.textContent = '‚è≥ Packing ZIP...';

                status.textContent = 'Generating ZIP file...';
                // Generate and download ZIP
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${folderName}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                btn.textContent = '‚úÖ Download Complete';
                status.textContent = 'Download started!';
                setTimeout(() => {
                    btn.disabled = false;
                    btn.textContent = 'üì¶ Download ZIP';
                    status.style.display = 'none';
                }, 3000);

            } catch (error) {
                console.error('Error downloading theme:', error);
                btn.textContent = '‚ùå Error';
                status.textContent = 'Download failed. Please try again.';
                alert('Error downloading theme. Please try again.');
                btn.disabled = false;
            }
        }

        // Global asset tracking for navigation
        window.assetNavigation = {
            assets: [],
            currentIndex: -1,
            currentImageCache: null
        };

        // Navigation functions
        function navigateAsset(direction) {
            if (!window.assetNavigation.assets || window.assetNavigation.assets.length === 0) return;

            const newIndex = window.assetNavigation.currentIndex + direction;
            if (newIndex < 0 || newIndex >= window.assetNavigation.assets.length) return;

            window.assetNavigation.currentIndex = newIndex;
            const asset = window.assetNavigation.assets[newIndex];

            if (asset.type === 'special') {
                if (asset.filename === 'index.html') {
                    openLightbox('index-html', null, null);
                } else if (asset.filename === 'config.json') {
                    // Get config from stored data
                    const configData = window.configJsonData;
                    const imgCache = window.configJsonImageCache;
                    const fontFileData = window.configJsonFontFile;
                    openLightbox('config-json', null, configData, null, null, imgCache, fontFileData);
                }
            } else if (asset.type === 'image') {
                const cached = window.assetNavigation.currentImageCache ? window.assetNavigation.currentImageCache.get(asset.filename) : null;
                if (cached && cached.objectUrl) {
                    openLightbox(cached.objectUrl, asset.filename, null, null, null, window.assetNavigation.currentImageCache, null, asset.resourceValue || asset.filename);
                } else {
                    const githubUrl = getGitHubRawUrl(asset.filename);
                    openLightbox(githubUrl, asset.filename, null, null, null, window.assetNavigation.currentImageCache, null, asset.resourceValue || asset.filename);
                }
            } else if (asset.type === 'font') {
                const fontUrl = getGitHubRawUrl(asset.filename);
                const localFontUrl = getLocalUrl(asset.filename);
                openLightbox('font-preview', asset.filename, null, fontUrl, localFontUrl, window.assetNavigation.currentImageCache, null, asset.resourceValue || asset.filename);
            }

            // Sync navigation buttons and JSON highlighting after opening
            setTimeout(() => {
                syncNavigationButtons();
                syncJsonHighlighting();
            }, 300);
        }

        // Helper function to sync JSON highlighting with current asset
        function syncJsonHighlighting() {
            if (!window.assetNavigation.assets || window.assetNavigation.currentIndex < 0) return;

            const asset = window.assetNavigation.assets[window.assetNavigation.currentIndex];
            if (!asset) return;

            // Find JSON context in the wrapper
            const lightboxContentWrapper = document.getElementById('lightbox-content-wrapper');
            if (!lightboxContentWrapper || lightboxContentWrapper.style.display === 'none') return;

            const jsonPre = lightboxContentWrapper.querySelector('pre[id^="lightbox-json-"], pre[id^="font-json-"], pre[id^="image-json-"]');
            if (!jsonPre) return;

            // Try multiple strategies to find the resource line
            let context = null;
            if (asset.resourceValue && window.findJsonContextForResource) {
                context = window.findJsonContextForResource(asset.resourceValue, 0);
            }
            if (!context && asset.filename && window.findJsonContextForResource) {
                context = window.findJsonContextForResource(asset.filename, 0);
            }
            if (!context) return;

            const targetLine = jsonPre.querySelector(`.json-line[data-line="${context.lineNumber}"]`);
            if (targetLine) {
                // Clear all highlights
                jsonPre.querySelectorAll('.json-line').forEach(l => {
                    // Don't clear theme info highlights, only resource highlights
                    if (!l.querySelector('.json-theme-info')) {
                        l.style.background = '';
                    }
                });
                // Highlight target line persistently
                targetLine.style.background = 'rgba(102, 126, 234, 0.3)';
                targetLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function navigateJsonLine(direction) {
            // Find JSON context in wrapper (not separate panel)
            const lightboxContentWrapper = document.getElementById('lightbox-content-wrapper');
            if (!lightboxContentWrapper || lightboxContentWrapper.style.display === 'none') return;

            const jsonPre = lightboxContentWrapper.querySelector('pre[id^="lightbox-json-"], pre[id^="font-json-"], pre[id^="image-json-"]');
            if (!jsonPre) return;

            const allLines = Array.from(jsonPre.querySelectorAll('.json-line')).filter(line => {
                const resource = line.querySelector('.json-resource');
                return resource !== null; // Only lines with resources
            });

            if (allLines.length === 0) return;

            // Find currently highlighted line or current asset
            let currentLineIndex = -1;
            if (window.assetNavigation.currentIndex >= 0 && window.assetNavigation.assets) {
                const currentAsset = window.assetNavigation.assets[window.assetNavigation.currentIndex];
                if (currentAsset && currentAsset.resourceValue) {
                    const context = window.findJsonContextForResource ? window.findJsonContextForResource(currentAsset.resourceValue, 0) : null;
                    if (context) {
                        const targetLineNum = context.lineNumber;
                        allLines.forEach((line, idx) => {
                            const lineNum = parseInt(line.getAttribute('data-line'));
                            if (lineNum === targetLineNum) {
                                currentLineIndex = idx;
                            }
                        });
                    }
                }
            }

            // If no current line found, use first visible highlighted line
            if (currentLineIndex === -1) {
                allLines.forEach((line, idx) => {
                    if (line.style.background && line.style.background.includes('rgba(102, 126, 234')) {
                        currentLineIndex = idx;
                    }
                });
            }

            // Find next resource line
            let nextIndex = currentLineIndex + direction;
            if (nextIndex < 0) nextIndex = allLines.length - 1;
            if (nextIndex >= allLines.length) nextIndex = 0;

            const line = allLines[nextIndex];
            const resource = line.querySelector('.json-resource');
            if (resource) {
                // Get resource info
                const resourceType = resource.getAttribute('data-resource-type');
                const resourceValue = resource.getAttribute('data-resource-value');
                const resourceFilename = resource.getAttribute('data-resource-filename') || resourceValue.split('/').pop();

                // Find matching asset in navigation list and update index
                if (window.assetNavigation.assets) {
                    const assetIndex = window.assetNavigation.assets.findIndex(a =>
                        (a.type === 'image' || a.type === 'font') &&
                        (a.filename === resourceFilename || a.resourceValue === resourceValue)
                    );
                    if (assetIndex >= 0) {
                        window.assetNavigation.currentIndex = assetIndex;
                        syncNavigationButtons();
                    }
                }

                // Highlight and scroll to this line
                jsonPre.querySelectorAll('.json-line').forEach(l => l.style.background = '');
                line.style.background = 'rgba(102, 126, 234, 0.3)';
                line.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // Preview the asset
                setTimeout(() => {
                    if (resourceType === 'image') {
                        const cached = window.assetNavigation.currentImageCache ? window.assetNavigation.currentImageCache.get(resourceFilename) : null;
                        if (cached && cached.objectUrl) {
                            openLightbox(cached.objectUrl, resourceFilename, null, null, null, window.assetNavigation.currentImageCache, null, resourceValue);
                        } else {
                            const githubUrl = getGitHubRawUrl(resourceFilename);
                            openLightbox(githubUrl, resourceFilename, null, null, null, window.assetNavigation.currentImageCache, null, resourceValue);
                        }
                    } else if (resourceType === 'font') {
                        const fontUrl = getGitHubRawUrl(resourceValue);
                        const localFontUrl = getLocalUrl(resourceValue);
                        openLightbox('font-preview', resourceValue, null, fontUrl, localFontUrl, window.assetNavigation.currentImageCache, null, resourceValue);
                    }
                }, 100);
            }
        }

        function syncNavigationButtons() {
            const navLeft = document.getElementById('lightbox-nav-left');
            const navRight = document.getElementById('lightbox-nav-right');
            if (navLeft && navRight && window.assetNavigation.assets && window.assetNavigation.assets.length > 1) {
                // Always show buttons when lightbox is active (no keypress needed)
                navLeft.style.display = window.assetNavigation.currentIndex > 0 ? 'block' : 'none';
                navRight.style.display = window.assetNavigation.currentIndex < window.assetNavigation.assets.length - 1 ? 'block' : 'none';
            } else {
                // Hide if no assets or only one asset
                if (navLeft) navLeft.style.display = 'none';
                if (navRight) navRight.style.display = 'none';
            }
        }

        // Enhanced function to find asset index by any identifier
        function findAssetIndex(filename, resourceValue, jsonResourceValue) {
            if (!window.assetNavigation.assets || window.assetNavigation.assets.length === 0) return -1;

            // Try multiple matching strategies
            let assetIndex = window.assetNavigation.assets.findIndex(a => {
                if (a.filename === filename) return true;
                if (a.resourceValue === filename) return true;
                if (a.resourceValue === resourceValue) return true;
                if (a.resourceValue === jsonResourceValue) return true;
                if (jsonResourceValue && a.filename === jsonResourceValue) return true;
                if (jsonResourceValue && a.resourceValue === jsonResourceValue) return true;

                // Try extracting just the filename from paths
                const aFilename = a.filename ? a.filename.split('/').pop() : '';
                const aResourceValue = a.resourceValue ? a.resourceValue.split('/').pop() : '';
                const searchFilename = filename ? filename.split('/').pop() : '';
                const searchResourceValue = resourceValue ? resourceValue.split('/').pop() : '';
                const searchJsonResource = jsonResourceValue ? jsonResourceValue.split('/').pop() : '';

                if (aFilename === searchFilename) return true;
                if (aResourceValue === searchFilename) return true;
                if (aFilename === searchResourceValue) return true;
                if (aResourceValue === searchResourceValue) return true;
                if (searchJsonResource && (aFilename === searchJsonResource || aResourceValue === searchJsonResource)) return true;

                return false;
            });

            return assetIndex;
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            const lightbox = document.getElementById('lightbox');
            if (!lightbox || !lightbox.classList.contains('active')) return;

            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                e.preventDefault();
                navigateAsset(e.key === 'ArrowRight' ? 1 : -1);
            } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
                navigateJsonLine(e.key === 'ArrowDown' ? 1 : -1);
            } else if (e.key === 'Escape') {
                e.preventDefault();
                closeLightbox();
            }
        });

        // Lightbox functions
        function openLightbox(imgSrc, filename = null, extraData = null, fontUrl = null, localFontUrl = null, imageCache = null, fontFileData = null, jsonResourceValue = null) {
            const lightbox = document.getElementById('lightbox');
            const lightboxImg = document.getElementById('lightbox-img');
            const lightboxContentWrapper = document.getElementById('lightbox-content-wrapper');
            const editBtn = document.getElementById('lightbox-edit-btn');
            const filenameDisplay = document.getElementById('lightbox-filename');
            const lightboxJsonContext = document.getElementById('lightbox-json-context');

            const folderName = getFolderName();

            // Always clear and hide the separate JSON context panel first (to prevent duplicates)
            if (lightboxJsonContext) {
                lightboxJsonContext.style.display = 'none';
                lightboxJsonContext.innerHTML = '';
            }

            // Clear any existing JSON contexts in wrappers
            const allJsonContexts = document.querySelectorAll('[id^="lightbox-json-"], [id^="font-json-"], [id^="mini-json-"], [id^="image-json-"]');
            allJsonContexts.forEach(ctx => {
                if (ctx && ctx.parentElement) {
                    ctx.innerHTML = '';
                }
            });

            // Handle special content types
            if (imgSrc === 'transparent-assets' && extraData) {
                // Show transparent assets list
                lightboxImg.style.display = 'none';
                lightboxContentWrapper.style.display = 'block';
                lightboxContentWrapper.innerHTML = `
                    <h3 style="margin-top: 0; color: #667eea; margin-bottom: 20px;">Transparent Assets Usage</h3>
                    <p style="color: #666; margin-bottom: 20px;">These config keys use transparent image files:</p>
                    <ul style="list-style: none; padding: 0; margin: 0;">
                        ${extraData.map(key => `<li style="padding: 10px; margin: 5px 0; background: #f5f5f5; border-radius: 4px; font-family: monospace; font-size: 0.9rem;">${key}</li>`).join('')}
                    </ul>
                `;
                filenameDisplay.style.display = 'none';
                editBtn.style.display = 'none';
                lightbox.classList.add('active');
                document.body.style.overflow = 'hidden';
                return;
            }

            if (imgSrc === 'index-html') {
                // Show index.html explainer
                lightboxImg.style.display = 'none';
                lightboxContentWrapper.style.display = 'block';
                lightboxContentWrapper.innerHTML = `
                    <h3 style="margin-top: 0; color: #667eea; margin-bottom: 20px;">index.html Template</h3>
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #667eea; margin-bottom: 20px;">
                        <p style="margin: 0 0 15px 0; line-height: 1.6; color: #333;">
                            This <code style="background: rgba(102, 126, 234, 0.1); padding: 2px 6px; border-radius: 3px; font-family: monospace;">index.html</code> file can be downloaded and placed in your own theme folder.
                        </p>
                        <p style="margin: 0 0 15px 0; line-height: 1.6; color: #333;">
                            When you upload your theme to the <strong>GitHub Innioasis Y1 Themes Repository</strong>, this file will automatically create a dedicated page for your theme on <strong>themes.innioasis.app</strong>.
                        </p>
                        <p style="margin: 0; line-height: 1.6; color: #333;">
                            The page will automatically display your theme information, screenshots, and assets from your <code style="background: rgba(102, 126, 234, 0.1); padding: 2px 6px; border-radius: 3px; font-family: monospace;">config.json</code> file.
                        </p>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <button id="download-index-html-btn" style="display: inline-block; background: #667eea; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: 600; margin-right: 10px; border: none; cursor: pointer; font-size: 1rem;">üì• Download index.html</button>
                        <a href="https://themes.innioasis.app/yourTheme/" target="_blank" style="display: inline-block; color: #667eea; text-decoration: underline; padding: 12px 0;">Learn more ‚Üí</a>
                    </div>
                `;

                // Add download handler for index.html
                const downloadBtn = document.getElementById('download-index-html-btn');
                if (downloadBtn) {
                    downloadBtn.onclick = async function (e) {
                        e.stopPropagation();
                        const btn = this;
                        const originalText = btn.textContent;
                        btn.textContent = '‚è≥ Downloading...';
                        btn.disabled = true;

                        try {
                            // Fetch the index.html from the theme's directory
                            const indexUrl = getGitHubRawUrl('index.html');
                            const response = await fetch(indexUrl);
                            if (!response.ok) {
                                // Fallback to local
                                const localUrl = getLocalUrl('index.html');
                                const localResponse = await fetch(localUrl);
                                if (!localResponse.ok) throw new Error('Could not fetch index.html');
                                const blob = await localResponse.blob();
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = 'index.html';
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                URL.revokeObjectURL(url);
                            } else {
                                const blob = await response.blob();
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = 'index.html';
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                URL.revokeObjectURL(url);
                            }
                            btn.textContent = '‚úÖ Downloaded!';
                            setTimeout(() => {
                                btn.textContent = originalText;
                                btn.disabled = false;
                            }, 2000);
                        } catch (error) {
                            console.error('Error downloading index.html:', error);
                            btn.textContent = '‚ùå Error';
                            setTimeout(() => {
                                btn.textContent = originalText;
                                btn.disabled = false;
                            }, 2000);
                        }
                    };
                }

                filenameDisplay.textContent = 'index.html';
                filenameDisplay.style.display = 'block';
                const githubUrl = `https://github.com/y1-community/InnioasisY1Themes/blob/main/${encodeURIComponent(folderName)}/index.html`;
                editBtn.href = githubUrl;
                editBtn.style.display = 'inline-flex';
                lightbox.classList.add('active');
                document.body.style.overflow = 'hidden';
                return;
            }

            if (imgSrc === 'config-json' && extraData) {
                // Show formatted config.json with interactive previews
                lightboxImg.style.display = 'none';
                lightboxContentWrapper.style.display = 'block';

                // Theme info keys that should be highlighted
                const themeInfoKeys = ['title', 'author', 'authorUrl', 'description', 'name'];
                const themeInfoPaths = ['theme_info.title', 'theme_info.author', 'theme_info.authorUrl', 'theme_info.description', 'theme_info.name'];

                // Create interactive JSON viewer with line numbers and highlighting
                const createInteractiveJson = (obj, imageCache, fontFileData, indent = 0, path = '', lineNumber = 1) => {
                    let html = '';
                    const indentStr = '  '.repeat(indent);
                    let currentLine = lineNumber;

                    const escapeHtml = (str) => {
                        return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                    };

                    const escapeJs = (str) => {
                        return str.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r');
                    };

                    const isThemeInfoKey = (key, currentPath) => {
                        return themeInfoKeys.includes(key) || themeInfoPaths.some(p => currentPath.includes(p));
                    };

                    if (Array.isArray(obj)) {
                        html += `<span class="json-line" data-line="${currentLine++}">[</span>\n`;
                        obj.forEach((item, index) => {
                            html += `<span class="json-line" data-line="${currentLine}">${indentStr}  `;
                            if (typeof item === 'object' && item !== null) {
                                const result = createInteractiveJson(item, imageCache, fontFileData, indent + 1, path, currentLine);
                                html += result.html;
                                currentLine = result.lineNumber;
                            } else {
                                html += JSON.stringify(item);
                            }
                            if (index < obj.length - 1) html += ',';
                            html += `</span>\n`;
                            currentLine++;
                        });
                        html += `<span class="json-line" data-line="${currentLine++}">${indentStr}]</span>`;
                    } else if (typeof obj === 'object' && obj !== null) {
                        html += `<span class="json-line" data-line="${currentLine++}">{</span>\n`;
                        const keys = Object.keys(obj);
                        keys.forEach((key, index) => {
                            const value = obj[key];
                            const currentPath = path ? `${path}.${key}` : key;
                            const isThemeInfo = isThemeInfoKey(key, currentPath);
                            const lineNum = currentLine;
                            html += `<span class="json-line" data-line="${lineNum}" style="${isThemeInfo ? 'background: rgba(102, 126, 234, 0.1); padding: 2px 0; display: block;' : ''}">${indentStr}  `;
                            html += `<span style="color: ${isThemeInfo ? '#667eea' : '#f92672'}; font-weight: ${isThemeInfo ? '600' : 'normal'};">"${escapeHtml(key)}"</span>: `;

                            if (typeof value === 'string') {
                                const escapedValue = escapeHtml(value);
                                const jsEscapedValue = escapeJs(value);

                                // Check if it's an image file
                                if (/\.(png|jpg|jpeg|gif|svg)$/i.test(value)) {
                                    const filename = value.split('/').pop();
                                    const escapedFilename = escapeHtml(filename);
                                    const jsEscapedFilename = escapeJs(filename);
                                    html += `<span class="json-resource" data-resource-type="image" data-resource-value="${escapedValue}" data-resource-filename="${escapedFilename}" style="color: #a6e22e; cursor: pointer; text-decoration: underline; position: relative;" onmouseover="showResourcePreview(event, 'image', '${jsEscapedValue}', '${jsEscapedFilename}')" onmouseout="hideResourcePreview()" onclick="event.stopPropagation(); openResourcePreview('image', '${jsEscapedValue}', '${jsEscapedFilename}')">"${escapedValue}"</span>`;
                                }
                                // Check if it's a font file
                                else if (/\.(ttf|otf|woff|woff2)$/i.test(value) || (key === 'fontFamily' && value)) {
                                    html += `<span class="json-resource" data-resource-type="font" data-resource-value="${escapedValue}" style="color: #a6e22e; cursor: pointer; text-decoration: underline;" onmouseover="showResourcePreview(event, 'font', '${jsEscapedValue}')" onmouseout="hideResourcePreview()" onclick="event.stopPropagation(); openResourcePreview('font', '${jsEscapedValue}')">"${escapedValue}"</span>`;
                                }
                                // Regular string - highlight if theme info
                                else {
                                    let tooltipText = '';
                                    if (isThemeInfo) {
                                        if (key === 'title' || currentPath.includes('title')) {
                                            tooltipText = 'Theme title displayed on the theme page';
                                        } else if (key === 'author' || currentPath.includes('author')) {
                                            tooltipText = 'Theme author name displayed on the theme page';
                                        } else if (key === 'authorUrl' || currentPath.includes('authorUrl')) {
                                            tooltipText = 'Link to the theme author profile or website';
                                        } else if (key === 'description' || currentPath.includes('description')) {
                                            tooltipText = 'Theme description displayed on the theme page';
                                        } else if (key === 'name' || currentPath.includes('name')) {
                                            tooltipText = 'Theme name used for identification';
                                        } else {
                                            tooltipText = 'Theme information used to populate the theme page';
                                        }
                                        const escapedTooltip = escapeJs(tooltipText);
                                        html += `<span class="json-theme-info" data-tooltip="${escapeHtml(tooltipText)}" style="color: #667eea; font-weight: 600; cursor: help; position: relative; border-bottom: 1px dotted #667eea;" onmouseover="showThemeInfoTooltip(event, '${escapedTooltip}')" onmouseout="hideThemeInfoTooltip()">"${escapedValue}"</span>`;
                                    } else {
                                        html += `<span style="color: #e6db74;">"${escapedValue}"</span>`;
                                    }
                                }
                            } else if (typeof value === 'object' && value !== null) {
                                const result = createInteractiveJson(value, imageCache, fontFileData, indent + 1, currentPath, currentLine);
                                html += result.html;
                                currentLine = result.lineNumber;
                            } else {
                                html += `<span style="color: #ae81ff;">${JSON.stringify(value)}</span>`;
                            }

                            if (index < keys.length - 1) html += ',';
                            html += `</span>\n`;
                            currentLine++;
                        });
                        html += `<span class="json-line" data-line="${currentLine++}">${indentStr}}</span>`;
                    } else {
                        html += JSON.stringify(obj);
                    }

                    return { html, lineNumber: currentLine };
                };

                // Store formatted JSON with line numbers for context lookup
                const formattedJsonLines = JSON.stringify(extraData, null, 2).split('\n');
                const resourceContextMap = new Map(); // Map resource value to JSON path/context

                // Build resource context map
                const buildResourceContext = (obj, path = '') => {
                    for (const [key, value] of Object.entries(obj)) {
                        const currentPath = path ? `${path}.${key}` : key;
                        if (typeof value === 'string') {
                            if (/\.(png|jpg|jpeg|gif|svg|ttf|otf|woff|woff2)$/i.test(value) || (key === 'fontFamily' && value)) {
                                resourceContextMap.set(value, currentPath);
                            }
                        } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                            buildResourceContext(value, currentPath);
                        }
                    }
                };
                buildResourceContext(extraData);

                const interactiveJsonResult = createInteractiveJson(extraData, imageCache, fontFileData, 0, '', 1);
                const interactiveJson = interactiveJsonResult.html;

                // Store createInteractiveJson function globally for use in tooltips
                window.createInteractiveJson = createInteractiveJson;

                // Helper to find JSON context lines for a resource
                const findJsonContext = (resourceValue, contextLines = 3) => {
                    const escapedValue = JSON.stringify(resourceValue);
                    const lines = formattedJsonLines;
                    let targetLineIndex = -1;

                    // Find the line containing this resource
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].includes(resourceValue)) {
                            targetLineIndex = i;
                            break;
                        }
                    }

                    if (targetLineIndex === -1) return null;

                    const start = Math.max(0, targetLineIndex - contextLines);
                    const end = Math.min(lines.length, targetLineIndex + contextLines + 1);
                    const context = lines.slice(start, end);
                    const targetRelativeIndex = targetLineIndex - start;

                    return {
                        lines: context,
                        targetLineIndex: targetRelativeIndex,
                        lineNumber: targetLineIndex + 1,
                        startLineNumber: start + 1
                    };
                };

                lightboxContentWrapper.innerHTML = `
                    <h3 style="margin-top: 0; color: #667eea; margin-bottom: 20px;">config.json</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 0.9rem;">Hover or tap on image filenames and font names to preview them. Click on JSON context lines to jump to that location.</p>
                    <div id="resource-preview-popup" style="display: none; position: fixed; z-index: 10003; background: white; border-radius: 8px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); padding: 15px; max-width: 400px; pointer-events: none; font-size: 1rem;"></div>
                    <div style="background: #2d2d2d; border-radius: 4px; overflow: hidden; position: relative;">
                        <pre id="json-preview-pre" style="color: #f8f8f2; padding: 20px; padding-left: 60px; overflow-x: auto; font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; font-size: 0.85rem; line-height: 1.5; margin: 0; max-height: 60vh; overflow-y: auto; white-space: pre; word-wrap: normal; position: relative;"><code>${interactiveJson}</code></pre>
                        <div id="json-line-numbers" style="position: absolute; left: 0; top: 0; bottom: 0; width: 50px; background: #1e1e1e; color: #858585; font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; font-size: 0.85rem; padding: 20px 5px; text-align: right; user-select: none; line-height: 1.5;"></div>
                    </div>
                `;

                // Generate line numbers
                const jsonPre = document.getElementById('json-preview-pre');
                const lineNumbersDiv = document.getElementById('json-line-numbers');
                if (jsonPre && lineNumbersDiv) {
                    const lines = interactiveJson.split('\n');
                    lineNumbersDiv.innerHTML = lines.map((_, i) => `<div style="line-height: 1.5;">${i + 1}</div>`).join('');

                    // Make JSON lines clickable to scroll to that line
                    jsonPre.querySelectorAll('.json-line').forEach(line => {
                        const lineNum = parseInt(line.getAttribute('data-line'));
                        if (lineNum) {
                            line.style.cursor = 'pointer';
                            line.onclick = function (e) {
                                e.stopPropagation();
                                // Scroll to this line
                                line.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                // Highlight briefly
                                const originalBg = line.style.background;
                                line.style.background = 'rgba(102, 126, 234, 0.3)';
                                setTimeout(() => {
                                    line.style.background = originalBg;
                                }, 1000);
                            };
                        }
                    });
                }

                // Add preview functions to window
                window.showResourcePreview = function (event, type, value, filename) {
                    const popup = document.getElementById('resource-preview-popup');
                    if (!popup) return;

                    // Use mouse position for better cursor following - update on mousemove
                    const updatePosition = (e) => {
                        const mouseX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                        const mouseY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);

                        let popupLeft = mouseX + 20;
                        let popupTop = mouseY + 20;

                        // Adjust if popup would go off screen
                        if (popupLeft + 400 > window.innerWidth) {
                            popupLeft = mouseX - 420; // Show to the left of cursor
                        }
                        if (popupTop + 300 > window.innerHeight) {
                            popupTop = mouseY - 320; // Show above cursor
                        }
                        if (popupLeft < 10) popupLeft = 10;
                        if (popupTop < 10) popupTop = 10;

                        popup.style.left = popupLeft + 'px';
                        popup.style.top = popupTop + 'px';
                    };

                    // Initial position
                    updatePosition(event);

                    // Update position on mouse move
                    const moveHandler = (e) => updatePosition(e);
                    document.addEventListener('mousemove', moveHandler);
                    popup._moveHandler = moveHandler; // Store for cleanup

                    // Generate full interactive JSON for mini preview
                    let contextHtml = '';
                    if (window.configJsonData && window.createInteractiveJson) {
                        const configData = window.configJsonData;
                        const imgCache = window.configJsonImageCache || imageCache;
                        const fontFileData = window.configJsonFontFile || null;
                        const fullJsonResult = createInteractiveJson(configData, imgCache, fontFileData, 0, '', 1);
                        const fullJsonHtml = fullJsonResult.html;
                        const totalLines = fullJsonHtml.split('\n').length;
                        const uniqueId = 'mini-json-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

                        // Find target line for scrolling
                        const context = findJsonContext(value, 0);
                        let scrollToLine = 1;
                        if (context) {
                            scrollToLine = context.lineNumber;
                        }

                        contextHtml = `
                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #eee;">
                                <div style="font-size: 0.85rem; color: #999; margin-bottom: 8px; font-weight: 600;">Full config.json (scroll to find assets, click line to preview):</div>
                                <div style="background: #2d2d2d; border-radius: 4px; overflow: hidden; position: relative; max-height: 250px; overflow-y: auto;">
                                    <pre id="${uniqueId}" style="color: #f8f8f2; padding: 15px; padding-left: 50px; overflow-x: auto; font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; font-size: 0.75rem; line-height: 1.5; margin: 0; white-space: pre; word-wrap: normal; position: relative;"><code>${fullJsonHtml}</code></pre>
                                    <div style="position: absolute; left: 0; top: 0; bottom: 0; width: 40px; background: #1e1e1e; color: #858585; font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; font-size: 0.75rem; padding: 15px 5px; text-align: right; user-select: none; line-height: 1.5;">
                                        ${Array.from({ length: totalLines }, (_, i) => `<div style="line-height: 1.5;">${i + 1}</div>`).join('')}
                                    </div>
                                </div>
                            </div>
                        `;

                        // Scroll to target line after rendering
                        setTimeout(() => {
                            const miniPre = document.getElementById(uniqueId);
                            if (miniPre) {
                                const targetLine = miniPre.querySelector(`.json-line[data-line="${scrollToLine}"]`);
                                if (targetLine) {
                                    targetLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    targetLine.style.background = 'rgba(102, 126, 234, 0.3)';
                                    setTimeout(() => {
                                        targetLine.style.background = '';
                                    }, 2000);
                                }
                            }
                        }, 100);
                    }

                    if (type === 'image') {
                        const displayFilename = filename || value.split('/').pop();
                        const cached = imageCache ? imageCache.get(displayFilename) : null;
                        if (cached && cached.objectUrl) {
                            popup.innerHTML = `
                                <div style="font-size: 1rem; color: #333; margin-bottom: 10px; font-family: monospace; text-align: center; font-weight: 600;">${displayFilename}</div>
                                <img src="${cached.objectUrl}" style="max-width: 320px; max-height: 240px; border-radius: 4px; display: block; margin: 0 auto;" alt="${displayFilename}">
                                ${contextHtml}
                            `;
                        } else {
                            const githubUrl = getGitHubRawUrl(displayFilename);
                            popup.innerHTML = `
                                <div style="font-size: 1rem; color: #333; margin-bottom: 10px; font-family: monospace; text-align: center; font-weight: 600;">${displayFilename}</div>
                                <img src="${githubUrl}" style="max-width: 320px; max-height: 240px; border-radius: 4px; display: block; margin: 0 auto;" alt="${displayFilename}" onerror="this.parentElement.innerHTML='<div style=\\'padding: 20px; text-align: center; color: #999; font-size: 1rem;\\'>Image not available</div><div style=\\'font-size: 1rem; color: #999; margin-top: 8px; font-family: monospace; text-align: center;\\'>${displayFilename}</div>${contextHtml}'">
                                ${contextHtml}
                            `;
                        }
                    } else if (type === 'font') {
                        const fontFilename = value.split('/').pop();
                        popup.innerHTML = `
                            <div style="font-size: 1rem; color: #333; margin-bottom: 12px; font-family: monospace; text-align: center; font-weight: 600;">${fontFilename}</div>
                            <div style="padding: 15px; text-align: center; background: #f8f9fa; border-radius: 4px;">
                                <div style="font-size: 32px; font-family: 'PreviewFontPopup', sans-serif; margin-bottom: 10px;">AaBbCc 123</div>
                            </div>
                            ${contextHtml}
                        `;
                        // Try to load font
                        (async () => {
                            try {
                                const fontUrl = getGitHubRawUrl(value);
                                const fontFace = new FontFace('PreviewFontPopup', `url(${fontUrl})`);
                                await fontFace.load();
                                document.fonts.add(fontFace);
                            } catch (e) {
                                // Font load failed, ignore
                            }
                        })();
                    }

                    popup.style.display = 'block';
                };

                window.hideResourcePreview = function () {
                    const popup = document.getElementById('resource-preview-popup');
                    if (popup) {
                        popup.style.display = 'none';
                        // Remove mousemove handler
                        if (popup._moveHandler) {
                            document.removeEventListener('mousemove', popup._moveHandler);
                            popup._moveHandler = null;
                        }
                    }
                };

                // Theme info tooltip functions
                window.showThemeInfoTooltip = function (event, tooltipText) {
                    const popup = document.getElementById('resource-preview-popup');
                    if (!popup) return;

                    const updatePosition = (e) => {
                        const mouseX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                        const mouseY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);

                        let popupLeft = mouseX + 20;
                        let popupTop = mouseY + 20;

                        if (popupLeft + 300 > window.innerWidth) {
                            popupLeft = mouseX - 320;
                        }
                        if (popupTop + 100 > window.innerHeight) {
                            popupTop = mouseY - 120;
                        }
                        if (popupLeft < 10) popupLeft = 10;
                        if (popupTop < 10) popupTop = 10;

                        popup.style.left = popupLeft + 'px';
                        popup.style.top = popupTop + 'px';
                    };

                    updatePosition(event);

                    popup.innerHTML = `
                        <div style="font-size: 0.9rem; color: #333; font-weight: 600; margin-bottom: 6px;">Theme Info</div>
                        <div style="font-size: 0.85rem; color: #666; line-height: 1.4;">${tooltipText}</div>
                    `;
                    popup.style.display = 'block';

                    const moveHandler = (e) => updatePosition(e);
                    document.addEventListener('mousemove', moveHandler);
                    popup._moveHandler = moveHandler;
                };

                window.hideThemeInfoTooltip = function () {
                    window.hideResourcePreview();
                };

                window.openResourcePreview = function (type, value, filename) {
                    if (type === 'image') {
                        const cached = imageCache ? imageCache.get(filename) : null;
                        if (cached && cached.objectUrl) {
                            openLightbox(cached.objectUrl, filename, null, null, null, imageCache, null, value);
                        } else {
                            const githubUrl = getGitHubRawUrl(filename);
                            openLightbox(githubUrl, filename, null, null, null, imageCache, null, value);
                        }
                    } else if (type === 'font') {
                        const fontUrl = getGitHubRawUrl(value);
                        const localFontUrl = getLocalUrl(value);
                        openLightbox('font-preview', value, null, fontUrl, localFontUrl, imageCache, null, value);
                    }
                };

                window.formattedJsonLinesForContext = formattedJsonLines;
                window.configJsonData = extraData; // Store config for use in tooltips
                window.configJsonImageCache = imageCache; // Store image cache
                window.configJsonFontFile = fontFile; // Store font file

                // Enhanced findJsonContextForResource function - finds line by filename or full path
                window.findJsonContextForResource = function (resourceValue, contextLines = 3) {
                    if (!window.configJsonData || !resourceValue) return null;
                    const formattedJsonLines = JSON.stringify(window.configJsonData, null, 2).split('\n');

                    // Extract filename from resourceValue (handle paths)
                    const filename = resourceValue.split('/').pop();
                    const filenameNoExt = filename.replace(/\.[^.]+$/, '');

                    let targetLineIndex = -1;

                    // Try multiple matching strategies
                    for (let i = 0; i < formattedJsonLines.length; i++) {
                        const line = formattedJsonLines[i];

                        // Strategy 1: Exact match with resourceValue
                        if (line.includes(resourceValue)) {
                            targetLineIndex = i;
                            break;
                        }

                        // Strategy 2: Match filename (with quotes)
                        if (filename && line.includes(`"${filename}"`)) {
                            targetLineIndex = i;
                            break;
                        }

                        // Strategy 3: Match filename without quotes (handle special characters like @1x)
                        if (filename && line.includes(filename)) {
                            // Make sure it's actually part of a JSON value (after colon)
                            const colonIndex = line.indexOf(':');
                            const filenameIndex = line.indexOf(filename);
                            if (colonIndex >= 0 && filenameIndex > colonIndex) {
                                // Check if this looks like a valid filename match (within quotes or as part of path)
                                const beforeChar = line.charAt(filenameIndex - 1);
                                const afterChar = line.charAt(filenameIndex + filename.length);
                                // Allow various characters before/after (quotes, slashes, underscores, @, etc.)
                                if ((beforeChar === '"' || beforeChar === '/' || beforeChar === '_' || beforeChar === '@' || beforeChar === '.' || beforeChar === ' ') &&
                                    (afterChar === '"' || afterChar === '.' || afterChar === '@' || afterChar === ',' || afterChar === ' ' || afterChar === '')) {
                                    targetLineIndex = i;
                                    break;
                                }
                            }
                        }

                        // Strategy 4: Match by escaping special regex characters in filename
                        if (filename) {
                            // Escape special regex characters but allow @ and numbers
                            const escapedFilename = filename.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                            const regex = new RegExp(escapedFilename);
                            if (regex.test(line) && line.includes(':')) {
                                const colonIndex = line.indexOf(':');
                                const matchIndex = line.search(regex);
                                if (matchIndex > colonIndex) {
                                    targetLineIndex = i;
                                    break;
                                }
                            }
                        }
                    }

                    if (targetLineIndex === -1) return null;

                    const start = Math.max(0, targetLineIndex - contextLines);
                    const end = Math.min(formattedJsonLines.length, targetLineIndex + contextLines + 1);
                    const context = formattedJsonLines.slice(start, end);
                    const targetRelativeIndex = targetLineIndex - start;

                    return {
                        lines: context,
                        targetLineIndex: targetRelativeIndex,
                        lineNumber: targetLineIndex + 1,
                        startLineNumber: start + 1
                    };
                };

                // Function to scroll to a specific line in JSON preview
                window.scrollToJsonLine = function (lineNumber) {
                    const jsonPre = document.getElementById('json-preview-pre');
                    if (!jsonPre) return;

                    const lineElement = jsonPre.querySelector(`.json-line[data-line="${lineNumber}"]`);
                    if (lineElement) {
                        lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Highlight briefly
                        const originalBg = lineElement.style.background;
                        lineElement.style.background = 'rgba(102, 126, 234, 0.3)';
                        setTimeout(() => {
                            lineElement.style.background = originalBg;
                        }, 1500);
                    }
                };

                // Function to scroll to JSON line AND show asset preview
                window.scrollToJsonLineAndPreview = function (lineNumber, type, value, filename) {
                    // First scroll to the line
                    window.scrollToJsonLine(lineNumber);

                    // Then show the asset preview in lightbox
                    setTimeout(() => {
                        if (type === 'image') {
                            const cached = imageCache ? imageCache.get(filename) : null;
                            if (cached && cached.objectUrl) {
                                openLightbox(cached.objectUrl, filename, null, null, null, imageCache, null, value);
                            } else {
                                const githubUrl = getGitHubRawUrl(filename);
                                openLightbox(githubUrl, filename, null, null, null, imageCache, null, value);
                            }
                        } else if (type === 'font') {
                            const fontUrl = getGitHubRawUrl(value);
                            const localFontUrl = getLocalUrl(value);
                            openLightbox('font-preview', value, null, fontUrl, localFontUrl, imageCache, null, value);
                        }
                    }, 300); // Small delay to let scroll complete
                };

                filenameDisplay.textContent = 'config.json';
                filenameDisplay.style.display = 'block';
                const githubUrl = `https://github.com/y1-community/InnioasisY1Themes/blob/main/${encodeURIComponent(folderName)}/config.json`;
                editBtn.href = githubUrl;
                editBtn.style.display = 'inline-flex';

                // Set asset index for config.json
                if (window.assetNavigation.assets) {
                    const configIndex = window.assetNavigation.assets.findIndex(a => a.filename === 'config.json');
                    if (configIndex >= 0) {
                        window.assetNavigation.currentIndex = configIndex;
                        syncNavigationButtons();
                    }
                }

                lightbox.classList.add('active');
                document.body.style.overflow = 'hidden';
                return;
            }

            if (imgSrc === 'font-preview' && filename && fontUrl) {
                // Show font preview with JSON context if available
                lightboxImg.style.display = 'none';
                lightboxContentWrapper.style.display = 'block';

                // Hide separate JSON context panel (JSON is in wrapper)
                if (lightboxJsonContext) {
                    lightboxJsonContext.style.display = 'none';
                    lightboxJsonContext.innerHTML = '';
                }

                // Generate full interactive JSON for mini preview
                let jsonContextHtml = '';
                if (window.configJsonData && window.createInteractiveJson) {
                    const configData = window.configJsonData;
                    const imgCache = window.configJsonImageCache || imageCache;
                    const fontFileData = window.configJsonFontFile || null;
                    const fullJsonResult = window.createInteractiveJson(configData, imgCache, fontFileData, 0, '', 1);
                    const fullJsonHtml = fullJsonResult.html;
                    const totalLines = fullJsonHtml.split('\n').length;
                    const uniqueId = 'font-json-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

                    // Find target line for scrolling
                    const context = window.findJsonContextForResource ? window.findJsonContextForResource(filename, 0) : null;
                    let scrollToLine = 1;
                    if (context) {
                        scrollToLine = context.lineNumber;
                    }

                    const escapedValue = filename.replace(/'/g, "\\'");

                    jsonContextHtml = `
                        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                <div style="font-size: 0.8rem; color: #999; font-weight: 600;">config.json navigation (click lines or use ‚Üë‚Üì):</div>
                                <div style="display: flex; gap: 8px;">
                                    <button onclick="event.stopPropagation(); navigateJsonLine(-1)" style="background: #667eea; color: white; border: none; border-radius: 4px; width: 30px; height: 30px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">‚Üë</button>
                                    <button onclick="event.stopPropagation(); navigateJsonLine(1)" style="background: #667eea; color: white; border: none; border-radius: 4px; width: 30px; height: 30px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">‚Üì</button>
                                </div>
                            </div>
                            <div style="background: #2d2d2d; border-radius: 4px; overflow: hidden; position: relative; max-height: 200px; overflow-y: auto;">
                                <pre id="${uniqueId}" style="color: #f8f8f2; padding: 10px; padding-left: 42px; overflow-x: auto; font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; font-size: 0.7rem; line-height: 1.3; margin: 0; white-space: pre; word-wrap: normal; position: relative;"><code>${fullJsonHtml}</code></pre>
                                <div style="position: absolute; left: 0; top: 0; bottom: 0; width: 32px; background: #1e1e1e; color: #858585; font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; font-size: 0.7rem; padding: 10px 4px; text-align: right; user-select: none; line-height: 1.3;">
                                    ${Array.from({ length: totalLines }, (_, i) => `<div style="line-height: 1.3;">${i + 1}</div>`).join('')}
                                </div>
                            </div>
                        </div>
                    `;

                    // Scroll to target line and make lines clickable
                    setTimeout(() => {
                        const jsonPre = document.getElementById(uniqueId);
                        if (jsonPre) {
                            const targetLine = jsonPre.querySelector(`.json-line[data-line="${scrollToLine}"]`);
                            if (targetLine) {
                                targetLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                targetLine.style.background = 'rgba(102, 126, 234, 0.3)';
                                setTimeout(() => {
                                    targetLine.style.background = '';
                                }, 2000);
                            }

                            // Make all JSON lines clickable to navigate and preview
                            jsonPre.querySelectorAll('.json-line').forEach(line => {
                                const lineNum = parseInt(line.getAttribute('data-line'));
                                if (lineNum) {
                                    line.style.cursor = 'pointer';
                                    line.onclick = function (e) {
                                        e.stopPropagation();
                                        // Check if this line contains a resource
                                        const resource = line.querySelector('.json-resource');
                                        if (resource) {
                                            const resourceType = resource.getAttribute('data-resource-type');
                                            const resourceValue = resource.getAttribute('data-resource-value');
                                            const resourceFilename = resource.getAttribute('data-resource-filename') || resourceValue.split('/').pop();

                                            // Preview the asset
                                            if (resourceType === 'image') {
                                                const cached = imgCache ? imgCache.get(resourceFilename) : null;
                                                if (cached && cached.objectUrl) {
                                                    openLightbox(cached.objectUrl, resourceFilename, null, null, null, imgCache, null, resourceValue);
                                                } else {
                                                    const githubUrl = getGitHubRawUrl(resourceFilename);
                                                    openLightbox(githubUrl, resourceFilename, null, null, null, imgCache, null, resourceValue);
                                                }
                                            } else if (resourceType === 'font') {
                                                const fontUrl = getGitHubRawUrl(resourceValue);
                                                const localFontUrl = getLocalUrl(resourceValue);
                                                openLightbox('font-preview', resourceValue, null, fontUrl, localFontUrl, imgCache, null, resourceValue);
                                            }
                                        } else {
                                            // Just highlight the line if it doesn't contain a resource
                                            const originalBg = line.style.background;
                                            line.style.background = 'rgba(102, 126, 234, 0.3)';
                                            setTimeout(() => {
                                                line.style.background = originalBg;
                                            }, 1000);
                                        }
                                    };

                                    // Hover effect
                                    line.onmouseover = function () {
                                        if (!line.querySelector('.json-resource')) {
                                            this.style.background = 'rgba(102, 126, 234, 0.1)';
                                        }
                                    };
                                    line.onmouseout = function () {
                                        if (!line.querySelector('.json-resource')) {
                                            this.style.background = '';
                                        }
                                    };
                                }
                            });

                            // Also make resource links clickable directly (prevent double-firing)
                            jsonPre.querySelectorAll('.json-resource').forEach(resource => {
                                resource.onclick = function (e) {
                                    e.stopPropagation();
                                    // Let the line's onclick handle it
                                };
                            });
                        }
                    }, 100);
                }

                lightboxContentWrapper.innerHTML = `
                    <h3 style="margin-top: 0; color: #667eea; margin-bottom: 20px; font-size: 1.5rem;">Font Preview: ${filename}</h3>
                    <div style="font-size: 1rem; color: #666; margin-bottom: 15px; font-family: monospace; text-align: center; font-weight: 600;">${filename}</div>
                    <div id="font-preview-container" style="background: white; padding: 30px; border-radius: 4px; border: 1px solid #ddd;">
                        <p style="font-size: 48px; margin: 20px 0; font-family: 'PreviewFontDisplay', sans-serif;">AaBbCc 123</p>
                        <p style="font-size: 36px; margin: 20px 0; font-family: 'PreviewFontDisplay', sans-serif;">The quick brown fox jumps over the lazy dog</p>
                        <p style="font-size: 24px; margin: 20px 0; font-family: 'PreviewFontDisplay', sans-serif;">Sample text at different sizes</p>
                        <p style="font-size: 18px; margin: 20px 0; font-family: 'PreviewFontDisplay', sans-serif;">Lowercase and UPPERCASE letters</p>
                        <p style="font-size: 14px; margin: 20px 0; font-family: 'PreviewFontDisplay', sans-serif;">Numbers: 0123456789</p>
                    </div>
                    ${jsonContextHtml}
                `;

                // Load font for preview
                (async () => {
                    try {
                        const fontFace = new FontFace('PreviewFontDisplay', `url(${fontUrl})`);
                        await fontFace.load();
                        document.fonts.add(fontFace);
                    } catch (e) {
                        try {
                            const localFontFace = new FontFace('PreviewFontDisplay', `url(${localFontUrl})`);
                            await localFontFace.load();
                            document.fonts.add(localFontFace);
                        } catch (e2) {
                            console.warn('Could not load font for preview:', e2);
                        }
                    }
                })();

                filenameDisplay.textContent = filename;
                filenameDisplay.style.display = 'block';
                const githubUrl = `https://github.com/y1-community/InnioasisY1Themes/blob/main/${encodeURIComponent(folderName)}/${encodeURIComponent(filename)}`;
                editBtn.href = githubUrl;
                editBtn.style.display = 'inline-flex';

                // Sync JSON highlighting and navigation buttons after opening
                setTimeout(() => {
                    syncJsonHighlighting();
                    syncNavigationButtons();
                }, 300);

                lightbox.classList.add('active');
                document.body.style.overflow = 'hidden';
                return;
            }

            // Extract filename first before generating JSON context
            let actualFilename = filename;

            // If filename not provided, extract from imgSrc
            if (!actualFilename) {
                // Remove leading ./ if present
                const cleanSrc = imgSrc.replace(/^\.\//, '');

                // Handle blob: URLs (from carousel)
                if (imgSrc.startsWith('blob:')) {
                    actualFilename = cleanSrc.split('/').pop();
                } else {
                    // If the path contains a folder
                    if (cleanSrc.includes('/')) {
                        const parts = cleanSrc.split('/');
                        actualFilename = parts[parts.length - 1];
                    } else {
                        actualFilename = cleanSrc;
                    }
                }
            }

            // Remove URL parameters if present
            actualFilename = actualFilename.split('?')[0].split('#')[0];

            // Hide separate JSON context panel (we'll show JSON in the wrapper instead)
            if (lightboxJsonContext) {
                lightboxJsonContext.style.display = 'none';
                lightboxJsonContext.innerHTML = '';
            }

            // Default: Show image in consistent format like font previews
            lightboxImg.style.display = 'none';
            lightboxContentWrapper.style.display = 'block';

            // Generate JSON context for images too - ALWAYS show if config data is available
            let imageJsonContextHtml = '';

            // Ensure config data is available - try to load if not already loaded
            if (!window.configJsonData) {
                // Try to load config.json if not already available
                (async () => {
                    try {
                        const configResponse = await fetch('./config.json');
                        if (configResponse.ok) {
                            const config = await configResponse.json();
                            window.configJsonData = config;
                            // Trigger re-render with JSON context
                            setTimeout(() => {
                                openLightbox(imgSrc, actualFilename, null, null, null, imageCache, null, jsonResourceValue);
                            }, 100);
                        }
                    } catch (e) {
                        console.warn('Could not load config.json:', e);
                    }
                })();
            }

            if (window.configJsonData) {
                // Create interactive JSON function if it doesn't exist
                if (!window.createInteractiveJson) {
                    // Define createInteractiveJson function inline
                    window.createInteractiveJson = function (obj, imgCache, fontFileData, indent = 0, path = '', lineNumber = 1) {
                        let html = '';
                        const indentStr = '  '.repeat(indent);
                        let currentLine = lineNumber;

                        const escapeHtml = (str) => {
                            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                        };

                        if (Array.isArray(obj)) {
                            html += `<span class="json-line" data-line="${currentLine++}">[</span>\n`;
                            obj.forEach((item, index) => {
                                html += `<span class="json-line" data-line="${currentLine}">${indentStr}  `;
                                if (typeof item === 'object' && item !== null) {
                                    const result = window.createInteractiveJson(item, imgCache, fontFileData, indent + 1, path, currentLine);
                                    html += result.html;
                                    currentLine = result.lineNumber;
                                } else {
                                    html += JSON.stringify(item);
                                }
                                if (index < obj.length - 1) html += ',';
                                html += `</span>\n`;
                                currentLine++;
                            });
                            html += `<span class="json-line" data-line="${currentLine++}">${indentStr}]</span>`;
                        } else if (typeof obj === 'object' && obj !== null) {
                            html += `<span class="json-line" data-line="${currentLine++}">{</span>\n`;
                            const keys = Object.keys(obj);
                            keys.forEach((key, index) => {
                                const value = obj[key];
                                const currentPath = path ? `${path}.${key}` : key;
                                const lineNum = currentLine;
                                html += `<span class="json-line" data-line="${lineNum}">${indentStr}  <span style="color: #f92672;">"${escapeHtml(key)}"</span>: `;

                                if (typeof value === 'string') {
                                    const escapedValue = escapeHtml(value);

                                    // Check if it's an image file
                                    if (/\.(png|jpg|jpeg|gif|svg)$/i.test(value)) {
                                        const filename = value.split('/').pop();
                                        html += `<span class="json-resource" data-resource-type="image" data-resource-value="${escapedValue}" data-resource-filename="${escapeHtml(filename)}" style="color: #a6e22e; cursor: pointer; text-decoration: underline;">"${escapedValue}"</span>`;
                                    }
                                    // Check if it's a font file
                                    else if (/\.(ttf|otf|woff|woff2)$/i.test(value) || (key === 'fontFamily' && value)) {
                                        html += `<span class="json-resource" data-resource-type="font" data-resource-value="${escapedValue}" style="color: #a6e22e; cursor: pointer; text-decoration: underline;">"${escapedValue}"</span>`;
                                    } else {
                                        html += `<span style="color: #e6db74;">"${escapedValue}"</span>`;
                                    }
                                } else if (typeof value === 'object' && value !== null) {
                                    const result = window.createInteractiveJson(value, imgCache, fontFileData, indent + 1, currentPath, currentLine);
                                    html += result.html;
                                    currentLine = result.lineNumber;
                                } else {
                                    html += `<span style="color: #ae81ff;">${JSON.stringify(value)}</span>`;
                                }

                                if (index < keys.length - 1) html += ',';
                                html += `</span>\n`;
                                currentLine++;
                            });
                            html += `<span class="json-line" data-line="${currentLine++}">${indentStr}}</span>`;
                        } else {
                            html += JSON.stringify(obj);
                        }

                        return { html, lineNumber: currentLine };
                    };
                }

                if (window.createInteractiveJson) {
                    const configData = window.configJsonData;
                    const imgCache = window.configJsonImageCache || imageCache;
                    window.assetNavigation.currentImageCache = imgCache;
                    const fontFileData = window.configJsonFontFile || null;
                    const fullJsonResult = window.createInteractiveJson(configData, imgCache, fontFileData, 0, '', 1);
                    const fullJsonHtml = fullJsonResult.html;
                    const totalLines = fullJsonHtml.split('\n').length;
                    const uniqueId = 'image-json-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

                    // Find the correct line number for this resource
                    // Try multiple strategies to find the matching line
                    const resourceValue = jsonResourceValue || actualFilename;
                    let scrollToLine = 1;

                    if (resourceValue && window.findJsonContextForResource) {
                        // Try with resourceValue first (full path if available)
                        let context = window.findJsonContextForResource(resourceValue, 0);

                        // If not found, try with just the filename
                        if (!context && actualFilename) {
                            context = window.findJsonContextForResource(actualFilename, 0);
                        }

                        // If still not found, try extracting filename from resourceValue
                        if (!context && resourceValue.includes('/')) {
                            const extractedFilename = resourceValue.split('/').pop();
                            context = window.findJsonContextForResource(extractedFilename, 0);
                        }

                        if (context && context.lineNumber) {
                            scrollToLine = context.lineNumber;
                        }
                    }

                    imageJsonContextHtml = `
                    <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                            <div style="font-size: 0.8rem; color: #999; font-weight: 600;">config.json navigation (click lines or use ‚Üë‚Üì):</div>
                            <div style="display: flex; gap: 8px;">
                                <button onclick="event.stopPropagation(); navigateJsonLine(-1)" style="background: #667eea; color: white; border: none; border-radius: 4px; width: 30px; height: 30px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">‚Üë</button>
                                <button onclick="event.stopPropagation(); navigateJsonLine(1)" style="background: #667eea; color: white; border: none; border-radius: 4px; width: 30px; height: 30px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">‚Üì</button>
                            </div>
                        </div>
                        <div style="background: #2d2d2d; border-radius: 4px; overflow: hidden; position: relative; max-height: 200px; overflow-y: auto;">
                            <pre id="${uniqueId}" style="color: #f8f8f2; padding: 10px; padding-left: 42px; overflow-x: auto; font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; font-size: 0.7rem; line-height: 1.3; margin: 0; white-space: pre; word-wrap: normal; position: relative;"><code>${fullJsonHtml}</code></pre>
                            <div style="position: absolute; left: 0; top: 0; bottom: 0; width: 32px; background: #1e1e1e; color: #858585; font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; font-size: 0.7rem; padding: 10px 4px; text-align: right; user-select: none; line-height: 1.3;">
                                ${Array.from({ length: totalLines }, (_, i) => `<div style="line-height: 1.3;">${i + 1}</div>`).join('')}
                            </div>
                        </div>
                    </div>
                `;

                    // Make lines clickable after a short delay
                    setTimeout(() => {
                        const jsonPre = document.getElementById(uniqueId);
                        if (jsonPre) {
                            if (scrollToLine > 1) {
                                const targetLine = jsonPre.querySelector(`.json-line[data-line="${scrollToLine}"]`);
                                if (targetLine) {
                                    // Clear all existing highlights first
                                    jsonPre.querySelectorAll('.json-line').forEach(l => l.style.background = '');
                                    targetLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    // Keep highlight persistent (don't fade)
                                    targetLine.style.background = 'rgba(102, 126, 234, 0.3)';
                                }
                            }

                            // Make all JSON lines clickable
                            jsonPre.querySelectorAll('.json-line').forEach(line => {
                                const lineNum = parseInt(line.getAttribute('data-line'));
                                if (lineNum) {
                                    line.style.cursor = 'pointer';
                                    line.onclick = function (e) {
                                        e.stopPropagation();
                                        const resource = line.querySelector('.json-resource');
                                        if (resource) {
                                            const resourceType = resource.getAttribute('data-resource-type');
                                            const resourceValue = resource.getAttribute('data-resource-value');
                                            const resourceFilename = resource.getAttribute('data-resource-filename') || resourceValue.split('/').pop();

                                            // Find and set asset index BEFORE opening lightbox to sync navigation
                                            if (window.assetNavigation.assets) {
                                                const assetIndex = findAssetIndex(resourceFilename, resourceValue, resourceValue);
                                                if (assetIndex >= 0) {
                                                    window.assetNavigation.currentIndex = assetIndex;
                                                }
                                            }

                                            if (resourceType === 'image') {
                                                const cached = imgCache ? imgCache.get(resourceFilename) : null;
                                                if (cached && cached.objectUrl) {
                                                    openLightbox(cached.objectUrl, resourceFilename, null, null, null, imgCache, null, resourceValue);
                                                } else {
                                                    const githubUrl = getGitHubRawUrl(resourceFilename);
                                                    openLightbox(githubUrl, resourceFilename, null, null, null, imgCache, null, resourceValue);
                                                }
                                            } else if (resourceType === 'font') {
                                                const fontUrl = getGitHubRawUrl(resourceValue);
                                                const localFontUrl = getLocalUrl(resourceValue);
                                                openLightbox('font-preview', resourceValue, null, fontUrl, localFontUrl, imgCache, null, resourceValue);
                                            }
                                        }
                                    };
                                }
                            });
                        }
                    }, 100);
                }
            }

            lightboxContentWrapper.innerHTML = `
                <h3 style="margin-top: 0; color: #667eea; margin-bottom: 20px; font-size: 1.5rem;">Image Preview: ${actualFilename}</h3>
                <div style="font-size: 1rem; color: #666; margin-bottom: 15px; font-family: monospace; text-align: center; font-weight: 600;">${actualFilename}</div>
                <div id="image-preview-container" style="background: white; padding: 30px; border-radius: 4px; border: 1px solid #ddd;">
                    <img src="${imgSrc}" style="max-width: 100%; max-height: 60vh; object-fit: contain; display: block; margin: 0 auto;" alt="${actualFilename || 'Preview'}" onclick="event.stopPropagation()">
                </div>
                ${imageJsonContextHtml}
            `;
            lightboxImg.src = '';

            // Display filename in lightbox
            if (filenameDisplay) {
                filenameDisplay.textContent = actualFilename;
                filenameDisplay.style.display = 'block';
            }

            // Track current asset and set index - CRITICAL for navigation sync (do this BEFORE opening)
            if (actualFilename && imgSrc !== 'transparent-assets' && imgSrc !== 'index-html' && imgSrc !== 'config-json') {
                // Use enhanced findAssetIndex function
                const assetIndex = findAssetIndex(actualFilename, actualFilename, jsonResourceValue);
                if (assetIndex >= 0) {
                    window.assetNavigation.currentIndex = assetIndex;
                } else {
                    // Fallback: try to find by resource value
                    if (jsonResourceValue && window.assetNavigation.assets) {
                        const fallbackIndex = window.assetNavigation.assets.findIndex(a =>
                            a.resourceValue === jsonResourceValue ||
                            a.filename === jsonResourceValue ||
                            (a.resourceValue && a.resourceValue.includes(jsonResourceValue)) ||
                            (a.filename && a.filename.includes(jsonResourceValue))
                        );
                        if (fallbackIndex >= 0) {
                            window.assetNavigation.currentIndex = fallbackIndex;
                        }
                    }
                }
            } else if (imgSrc === 'index-html') {
                // Set index for index.html
                if (window.assetNavigation.assets) {
                    const htmlIndex = window.assetNavigation.assets.findIndex(a => a.filename === 'index.html');
                    if (htmlIndex >= 0) {
                        window.assetNavigation.currentIndex = htmlIndex;
                    }
                }
            } else if (imgSrc === 'config-json') {
                // Set index for config.json
                if (window.assetNavigation.assets) {
                    const configIndex = window.assetNavigation.assets.findIndex(a => a.filename === 'config.json');
                    if (configIndex >= 0) {
                        window.assetNavigation.currentIndex = configIndex;
                    }
                }
            } else if (imgSrc === 'font-preview' && filename) {
                // Set index for font
                if (window.assetNavigation.assets) {
                    const fontIndex = window.assetNavigation.assets.findIndex(a =>
                        a.type === 'font' && (a.filename === filename || a.resourceValue === filename)
                    );
                    if (fontIndex >= 0) {
                        window.assetNavigation.currentIndex = fontIndex;
                    }
                }
            }

            // Sync navigation buttons immediately (show for all navigable assets) - BEFORE opening lightbox
            syncNavigationButtons();

            // Sync JSON highlighting after opening
            setTimeout(() => {
                syncJsonHighlighting();
                syncNavigationButtons(); // Sync again after highlighting
            }, 300);

            // Construct GitHub URL using blob/main to view the actual file
            const githubUrl = `https://github.com/y1-community/InnioasisY1Themes/blob/main/${encodeURIComponent(folderName)}/${encodeURIComponent(actualFilename)}`;
            editBtn.href = githubUrl;
            editBtn.style.display = 'inline-flex';

            // Activate lightbox AFTER everything is set up
            lightbox.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeLightbox() {
            const lightbox = document.getElementById('lightbox');
            const lightboxImg = document.getElementById('lightbox-img');
            const lightboxContentWrapper = document.getElementById('lightbox-content-wrapper');
            const filenameDisplay = document.getElementById('lightbox-filename');
            const editBtn = document.getElementById('lightbox-edit-btn');
            lightbox.classList.remove('active');
            document.body.style.overflow = 'auto';
            if (lightboxImg) {
                lightboxImg.style.display = 'block';
                lightboxImg.src = '';
            }
            if (lightboxContentWrapper) {
                lightboxContentWrapper.style.display = 'none';
                lightboxContentWrapper.innerHTML = '';
            }
            if (lightboxJsonContext) {
                lightboxJsonContext.style.display = 'none';
                lightboxJsonContext.innerHTML = '';
            }
            if (filenameDisplay) {
                filenameDisplay.style.display = 'none';
            }
            if (editBtn) {
                editBtn.style.display = 'inline-flex';
            }
        }

        // Close lightbox on ESC key
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                closeLightbox();
                closeInstallModal();
            }
        });

        // File cache for downloaded files (used by download/install functions)
        // This cache is populated when images are loaded in the gallery
        const fileCache = new Map(); // Key: filename, Value: { blob, arrayBuffer }

        // Load screenshots gallery (larger carousel above Theme Assets)
        async function loadScreenshots() {
            const folderName = getFolderName();
            const screenshotsWrapper = document.getElementById('screenshots-carousel-wrapper');
            const screenshotsInfo = document.getElementById('screenshots-info');

            if (!screenshotsWrapper) return;

            try {
                let screenshotFiles = [];

                // Strategy 1: Try GitHub API to get file list (if available)
                try {
                    const apiUrl = `https://api.github.com/repos/y1-community/InnioasisY1Themes/contents/${encodeURIComponent(folderName)}`;
                    const response = await fetch(apiUrl);
                    if (response.ok) {
                        const files = await response.json();
                        // Filter for *screenshot*.* patterns only (exclude covers - case-insensitive)
                        const allScreenshotFiles = files
                            .filter(file => file.type === 'file' &&
                                /\.(gif|jpg|jpeg|png)$/i.test(file.name) &&
                                /screenshot/i.test(file.name))
                            .map(file => ({
                                name: file.name,
                                url: getGitHubRawUrl(file.name), // Use GitHub raw URL for faster loading
                                localUrl: `./${encodeURIComponent(file.name)}`, // Fallback local URL
                                download_url: file.download_url || getGitHubRawUrl(file.name)
                            }));

                        // Deduplicate: If multiple formats exist for same base name, keep only the best one
                        // Priority: GIF > JPG/JPEG > PNG
                        const screenshotMap = new Map(); // base name -> best format
                        const extensionPriority = { 'gif': 1, 'jpg': 2, 'jpeg': 2, 'png': 3 };

                        allScreenshotFiles.forEach(file => {
                            const filename = file.name;
                            const ext = filename.split('.').pop().toLowerCase();
                            const baseName = filename.substring(0, filename.lastIndexOf('.'));
                            const priority = extensionPriority[ext] || 99;

                            if (!screenshotMap.has(baseName) || priority < screenshotMap.get(baseName).priority) {
                                screenshotMap.set(baseName, { file, priority });
                            }
                        });

                        screenshotFiles = Array.from(screenshotMap.values()).map(item => item.file);
                    }
                } catch (apiError) {
                    console.log('GitHub API not available for screenshots, using pattern discovery');
                }

                // Strategy 2: If API didn't work, try common patterns
                if (screenshotFiles.length === 0) {
                    // Only check the most common screenshot patterns to avoid overwhelming the server
                    const screenshotPatterns = [
                        'screenshot.png', 'screenshot.jpg', 'screenshot.jpeg', 'screenshot.gif',
                        'screenshot2.png', 'screenshot2.jpg', 'screenshot2.jpeg', 'screenshot2.gif',
                        'screenshot3.png', 'screenshot3.jpg', 'screenshot3.jpeg', 'screenshot3.gif',
                        'screenshot4.png', 'screenshot4.jpg', 'screenshot4.jpeg', 'screenshot4.gif',
                        'Screenshot.png', 'Screenshot.jpg', 'Screenshot.jpeg', 'Screenshot.gif'
                    ];

                    screenshotFiles = screenshotPatterns.map(filename => ({
                        name: filename,
                        url: getGitHubRawUrl(filename),
                        localUrl: `./${encodeURIComponent(filename)}`,
                        download_url: getGitHubRawUrl(filename)
                    }));
                }

                if (screenshotFiles.length === 0) {
                    screenshotsWrapper.innerHTML = '<div style="text-align: center; padding: 40px; color: #999; width: 100%;">No screenshots found</div>';
                    if (screenshotsInfo) screenshotsInfo.textContent = '0 / 0';
                    return;
                }

                // Clear loading message
                screenshotsWrapper.innerHTML = '';

                // Load and display screenshots
                const loadedScreenshots = [];

                for (const file of screenshotFiles) {
                    try {
                        // Try local URL first (works on GitHub Pages and localhost)
                        let imageUrl = file.localUrl || `./${encodeURIComponent(file.name)}`;
                        let response = await fetch(imageUrl, { method: 'HEAD' });

                        // If local URL fails, try GitHub raw URL as fallback
                        if (!response.ok && file.url) {
                            imageUrl = file.url;
                            response = await fetch(imageUrl, { method: 'HEAD' });
                        }

                        if (response.ok) {
                            // File exists, load it
                            const fullResponse = await fetch(imageUrl);
                            if (fullResponse.ok) {
                                const blob = await fullResponse.blob();
                                const objectUrl = URL.createObjectURL(blob);

                                // Cache for download/install
                                const arrayBuffer = await blob.arrayBuffer();
                                fileCache.set(file.name, {
                                    blob: blob,
                                    arrayBuffer: arrayBuffer,
                                    url: imageUrl
                                });

                                loadedScreenshots.push({
                                    name: file.name,
                                    url: imageUrl,
                                    objectUrl: objectUrl
                                });
                            }
                        }
                    } catch (err) {
                        // File doesn't exist, skip it
                        continue;
                    }
                }

                if (loadedScreenshots.length === 0) {
                    screenshotsWrapper.innerHTML = '<div style="text-align: center; padding: 40px; color: #999; width: 100%;">No screenshots found</div>';
                    if (screenshotsInfo) screenshotsInfo.textContent = '0 / 0';
                    return;
                }

                // Sort by filename for consistent display
                loadedScreenshots.sort((a, b) => a.name.localeCompare(b.name));

                // Create carousel items
                loadedScreenshots.forEach((screenshot) => {
                    const item = document.createElement('div');
                    item.className = 'screenshots-carousel-item';
                    item.onclick = () => openLightbox(screenshot.objectUrl || screenshot.url, screenshot.name);
                    item.style.cursor = 'pointer';
                    item.title = screenshot.name; // Show filename on hover

                    const img = document.createElement('img');
                    img.src = screenshot.objectUrl || screenshot.url;
                    img.alt = screenshot.name;
                    img.loading = 'lazy';

                    item.appendChild(img);
                    screenshotsWrapper.appendChild(item);
                });

                // Update info
                if (screenshotsInfo) {
                    screenshotsInfo.textContent = `${loadedScreenshots.length} / ${loadedScreenshots.length}`;
                }

            } catch (error) {
                console.error('Error loading screenshots:', error);
                screenshotsWrapper.innerHTML = '<div style="text-align: center; padding: 40px; color: #999; width: 100%;">Error loading screenshots</div>';
            }
        }

        // Screenshots carousel navigation
        function scrollScreenshotsCarousel(direction) {
            const wrapper = document.getElementById('screenshots-carousel-wrapper');
            if (!wrapper) return;

            const scrollAmount = 265; // Width of item (250px) + gap (15px)
            wrapper.scrollBy({
                left: direction * scrollAmount,
                behavior: 'smooth'
            });
        }

        // Load all theme images for carousel
        // This function discovers all .jpg and .png files in the theme folder
        // Images are loaded using relative paths (works locally and on GitHub Pages)
        // This also helps speed up ZIP downloads as images are already cached in browser
        async function loadThemeImages() {
            const folderName = getFolderName();
            const carouselWrapper = document.getElementById('image-carousel-wrapper');
            const carouselInfo = document.getElementById('carousel-info');

            if (!carouselWrapper) return;

            try {
                // Load config.json to map images to their usage
                let config = null;
                let imageUsageMap = new Map(); // Maps filename -> array of config keys
                let transparentFilesMap = new Map(); // Maps transparent filename -> array of config keys
                let fontFile = null; // Track font file (fontFamily property)

                try {
                    const configResponse = await fetch('./config.json');
                    if (configResponse.ok) {
                        config = await configResponse.json();

                        // Helper function to recursively search for image references
                        function findImageReferences(obj, prefix = '') {
                            for (const [key, value] of Object.entries(obj)) {
                                if (typeof value === 'string') {
                                    // Check for font files
                                    if (key === 'fontFamily' && /\.(ttf|otf|woff|woff2)$/i.test(value)) {
                                        fontFile = value.split('/').pop();
                                    }
                                    // Check for image files
                                    else if (/\.(png|jpg|jpeg|gif|svg)$/i.test(value)) {
                                        // Extract filename and create multiple lookup keys
                                        const fullPath = value.split('/').pop();
                                        const filename = fullPath;

                                        // Check if this is a transparent file
                                        const isTransparent = /^transparent\./i.test(filename);

                                        // Create lookup keys:
                                        // 1. Full filename (e.g., "@Be_itemSelectedBackground.png")
                                        // 2. Without @ prefix pattern (e.g., "itemSelectedBackground.png")
                                        // 3. Base name without extension (e.g., "itemSelectedBackground")

                                        const keys = [filename];

                                        // Try removing @ prefix pattern (e.g., @Be_ or @Theme_)
                                        const withoutPrefix = filename.replace(/^@[^_]+_/, '');
                                        if (withoutPrefix !== filename) {
                                            keys.push(withoutPrefix);
                                        }

                                        // Base name without extension
                                        const baseName = filename.replace(/\.[^.]+$/, '');
                                        const baseNameWithoutPrefix = withoutPrefix.replace(/\.[^.]+$/, '');
                                        keys.push(baseName, baseNameWithoutPrefix);

                                        // Store the config key for all variations
                                        const fullKey = prefix ? `${prefix}.${key}` : key;

                                        if (isTransparent) {
                                            // Track transparent files separately
                                            keys.forEach(lookupKey => {
                                                if (!transparentFilesMap.has(lookupKey)) {
                                                    transparentFilesMap.set(lookupKey, []);
                                                }
                                                if (!transparentFilesMap.get(lookupKey).includes(fullKey)) {
                                                    transparentFilesMap.get(lookupKey).push(fullKey);
                                                }
                                            });
                                        } else {
                                            // Track regular image files
                                            keys.forEach(lookupKey => {
                                                if (!imageUsageMap.has(lookupKey)) {
                                                    imageUsageMap.set(lookupKey, []);
                                                }
                                                if (!imageUsageMap.get(lookupKey).includes(fullKey)) {
                                                    imageUsageMap.get(lookupKey).push(fullKey);
                                                }
                                            });
                                        }
                                    }
                                } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                                    const newPrefix = prefix ? `${prefix}.${key}` : key;
                                    findImageReferences(value, newPrefix);
                                }
                            }
                        }

                        // Search all config sections
                        findImageReferences(config);

                        // Store config data globally for JSON context in asset previews
                        window.configJsonData = config;
                        window.configJsonImageCache = imageCache;
                        if (fontFile) {
                            window.configJsonFontFile = fontFile;
                        }

                        // Build a map of resource values to line numbers in the formatted JSON
                        // This will be used to sort assets by their appearance order in config.json
                        window.resourceLineNumbers = new Map();
                        const formattedJson = JSON.stringify(config, null, 2);
                        const jsonLines = formattedJson.split('\n');

                        // Find line numbers for each resource (images and fonts)
                        jsonLines.forEach((line, index) => {
                            const lineNum = index + 1;
                            // Check for image files
                            const imageMatch = line.match(/"([^"]*\.(png|jpg|jpeg|gif|svg))"/i);
                            if (imageMatch) {
                                const filename = imageMatch[1].split('/').pop();
                                if (!window.resourceLineNumbers.has(filename)) {
                                    window.resourceLineNumbers.set(filename, lineNum);
                                }
                            }
                            // Check for font files
                            if (fontFile && line.includes(fontFile)) {
                                if (!window.resourceLineNumbers.has(fontFile)) {
                                    window.resourceLineNumbers.set(fontFile, lineNum);
                                }
                            }
                        });

                        // Also store createInteractiveJson function if available (it's defined in config.json preview section)
                        // We'll ensure it's available when needed
                    }
                } catch (e) {
                    console.warn('Could not load config.json for image mapping:', e);
                }

                let imageFiles = [];

                // Strategy 1: Try GitHub API to get file list (if available)
                try {
                    const apiUrl = `https://api.github.com/repos/y1-community/InnioasisY1Themes/contents/${encodeURIComponent(folderName)}`;
                    const response = await fetch(apiUrl);
                    if (response.ok) {
                        const files = await response.json();
                        imageFiles = files
                            .filter(file => file.type === 'file' &&
                                /\.png$/i.test(file.name) && // Only PNG files for asset gallery
                                // Exclude screenshots, cover images, and transparent files
                                !/screenshot/i.test(file.name) && !/cover/i.test(file.name) && !/^transparent\./i.test(file.name))
                            .map(file => ({
                                name: file.name,
                                url: getGitHubRawUrl(file.name), // Use GitHub raw URL for faster loading
                                localUrl: `./${encodeURIComponent(file.name)}`, // Fallback local URL
                                download_url: file.download_url || getGitHubRawUrl(file.name)
                            }));
                    }
                } catch (apiError) {
                    console.log('GitHub API not available, using pattern discovery');
                }

                // Strategy 2: If API didn't work or returned no files, try common patterns including wildcards
                // This works for local development and GitHub Pages
                if (imageFiles.length === 0) {
                    const imageExtensions = ['png', 'jpg', 'jpeg', 'gif'];
                    const commonBaseNames = [
                        '1', '1_YS', '2', '2_YS', '3', '4', '4_YS',
                        'background', 'bg', 'desktopWallpaper', 'globalWallpaper'
                    ];

                    // Build list of potential image files
                    for (const base of commonBaseNames) {
                        for (const ext of imageExtensions) {
                            const filename = `${base}.${ext}`;
                            imageFiles.push({
                                name: filename,
                                url: `./${encodeURIComponent(filename)}`,
                                download_url: `./${encodeURIComponent(filename)}`
                            });
                        }
                    }

                    // Note: Screenshots and cover images are NOT included here - they're loaded separately in loadScreenshots()
                }

                if (imageFiles.length === 0) {
                    carouselWrapper.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">No images found</div>';
                    if (carouselInfo) carouselInfo.textContent = '0 / 0';
                    return;
                }

                // Clear loading message
                carouselWrapper.innerHTML = '';

                // Build a list of all config key -> image filename mappings
                // This allows the same image to appear multiple times if used in multiple places
                const configImageEntries = []; // Array of {filename, configKey, url}
                const imageCache = new Map(); // Cache loaded images to avoid re-fetching

                // Iterate through all config keys that reference images
                // Only include PNG files (exclude transparent files - they're handled separately)
                imageUsageMap.forEach((configKeys, filename) => {
                    // Skip transparent files and non-PNG files
                    if (/^transparent\./i.test(filename) || !/\.png$/i.test(filename)) {
                        return;
                    }

                    // For each config key that uses this filename, create an entry
                    configKeys.forEach(configKey => {
                        configImageEntries.push({
                            filename: filename,
                            configKey: configKey
                        });
                    });
                });

                // Check if config.json was loaded successfully
                if (!config) {
                    // config.json is missing - show error message for theme creators
                    carouselWrapper.innerHTML = `
                        <div style="text-align: center; padding: 30px; color: #666; max-width: 600px; margin: 0 auto;">
                            <h4 style="color: #ff9800; margin-bottom: 15px;">‚ö†Ô∏è config.json Not Found</h4>
                            <p style="margin-bottom: 15px; line-height: 1.6;">
                                This theme page requires a <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">config.json</code> file in the theme folder to display theme assets and information.
                            </p>
                            <p style="margin-bottom: 15px; line-height: 1.6;">
                                <strong>Theme creators:</strong> Please download the latest <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px;">index.html</code> file from the <a href="https://themes.innioasis.app/yourTheme/" target="_blank" style="color: #667eea; text-decoration: underline;">yourTheme directory</a> and place it in your theme folder before uploading to the repository.
                            </p>
                            <p style="margin-top: 20px;">
                                <a href="https://raw.githubusercontent.com/y1-community/InnioasisY1Themes/main/yourTheme/index.html" download="index.html" target="_blank" style="display: inline-block; background: #667eea; color: white; padding: 10px 20px; border-radius: 6px; text-decoration: none; font-weight: 600;">üì• Download index.html Template</a>
                            </p>
                        </div>
                    `;
                    if (carouselInfo) carouselInfo.textContent = '0 / 0';
                    return;
                }

                if (configImageEntries.length === 0) {
                    carouselWrapper.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">No images found in config.json</div>';
                    if (carouselInfo) carouselInfo.textContent = '0 / 0';
                    return;
                }

                // Load all unique images and create gallery items for each config usage
                const loadedImageData = []; // Array of {filename, url, objectUrl, configKey}
                const uniqueFilenames = new Set();

                // First, collect all unique filenames we need to load
                configImageEntries.forEach(entry => {
                    uniqueFilenames.add(entry.filename);
                });

                // Load each unique image once
                const loadPromises = Array.from(uniqueFilenames).map(async (filename) => {
                    // Try multiple strategies to find the actual file
                    let imageUrl = null;

                    // Strategy 1: Direct filename match in imageFiles
                    let foundInFiles = imageFiles.find(f => {
                        const fName = f.name;
                        return fName === filename ||
                            fName.toLowerCase() === filename.toLowerCase();
                    });

                    let localUrl = null;

                    if (foundInFiles) {
                        imageUrl = foundInFiles.url; // GitHub raw URL
                        localUrl = foundInFiles.localUrl || `./${encodeURIComponent(filename)}`;
                    } else {
                        // Strategy 2: Try GitHub raw URL first, then local
                        imageUrl = getGitHubRawUrl(filename);
                        localUrl = `./${encodeURIComponent(filename)}`;

                        // Strategy 3: Try to find similar filenames (case-insensitive, without @ prefix)
                        const filenameLower = filename.toLowerCase();
                        const filenameBase = filename.replace(/^@[^_]+_/, '');
                        const filenameBaseLower = filenameBase.toLowerCase();

                        foundInFiles = imageFiles.find(f => {
                            const fName = f.name;
                            const fNameLower = fName.toLowerCase();
                            return fNameLower === filenameLower ||
                                fNameLower === filenameBaseLower ||
                                fName.replace(/^@[^_]+_/, '').toLowerCase() === filenameBaseLower;
                        });

                        if (foundInFiles) {
                            imageUrl = foundInFiles.url; // GitHub raw URL
                            localUrl = foundInFiles.localUrl || `./${encodeURIComponent(filename)}`;
                        }
                    }

                    if (!imageUrl) {
                        // Fallback: try GitHub raw URL, then local
                        imageUrl = getGitHubRawUrl(filename);
                        localUrl = `./${encodeURIComponent(filename)}`;
                    }

                    try {
                        // Fetch the image and cache it - try GitHub raw URL first, then fallback to local
                        let response = await fetch(imageUrl, { method: 'HEAD' });
                        if (!response.ok && localUrl) {
                            // Fallback to local URL
                            imageUrl = localUrl;
                            response = await fetch(imageUrl, { method: 'HEAD' });
                        }

                        if (!response.ok) {
                            // Skip this image if both URLs fail
                            return null;
                        }

                        const fullResponse = await fetch(imageUrl);
                        if (fullResponse.ok) {
                            const blob = await fullResponse.blob();
                            const arrayBuffer = await blob.arrayBuffer();

                            // Cache the file for download/install
                            fileCache.set(filename, {
                                blob: blob,
                                arrayBuffer: arrayBuffer,
                                url: imageUrl
                            });

                            // Create object URL for display
                            const objectUrl = URL.createObjectURL(blob);

                            // Check if PNG is fully transparent
                            let isTransparent = false;
                            if (/\.png$/i.test(filename)) {
                                isTransparent = await isFullyTransparent(objectUrl);
                            }

                            imageCache.set(filename, {
                                url: imageUrl,
                                objectUrl: objectUrl,
                                blob: blob,
                                isTransparent: isTransparent
                            });
                        } else {
                            console.warn(`Could not load image: ${filename} (HTTP ${fullResponse.status})`);
                        }
                    } catch (err) {
                        // Image doesn't exist or failed to load, skip it
                        console.warn(`Could not load image: ${filename}`, err);
                    }
                });

                await Promise.all(loadPromises);

                // Store image cache globally for JSON context in asset previews
                window.configJsonImageCache = imageCache;
                if (fontFile) {
                    window.configJsonFontFile = fontFile;
                }

                // Now create gallery items - one for each config key usage
                // This means the same image can appear multiple times if used in multiple places
                configImageEntries.forEach(entry => {
                    const cached = imageCache.get(entry.filename);
                    if (cached) {
                        // Get line number for this asset (from resourceLineNumbers map)
                        const lineNumber = window.resourceLineNumbers ? window.resourceLineNumbers.get(entry.filename) : 9999;
                        loadedImageData.push({
                            filename: entry.filename,
                            url: cached.url,
                            objectUrl: cached.objectUrl,
                            configKey: entry.configKey,
                            isTransparent: cached.isTransparent || false,
                            lineNumber: lineNumber || 9999 // Default to end if line number not found
                        });
                    }
                });

                // Sort by line number (JSON appearance order), then by config key name as tiebreaker
                loadedImageData.sort((a, b) => {
                    if (a.lineNumber !== b.lineNumber) {
                        return a.lineNumber - b.lineNumber;
                    }
                    return a.configKey.localeCompare(b.configKey);
                });

                // Build comprehensive asset list for navigation (includes all assets in order)
                window.assetNavigation.assets = [];
                window.assetNavigation.currentImageCache = imageCache;

                // Add index.html
                window.assetNavigation.assets.push({
                    type: 'special',
                    filename: 'index.html',
                    displayName: 'index.html'
                });

                // Add config.json
                if (config) {
                    window.assetNavigation.assets.push({
                        type: 'special',
                        filename: 'config.json',
                        displayName: 'config.json'
                    });
                }

                // Add font (third)
                if (fontFile) {
                    const fontLineNumber = window.resourceLineNumbers ? window.resourceLineNumbers.get(fontFile) : 9999;
                    window.assetNavigation.assets.push({
                        type: 'font',
                        filename: fontFile,
                        displayName: `fontFamily: ${fontFile}`,
                        resourceValue: fontFile,
                        lineNumber: fontLineNumber || 9999
                    });
                }

                // Add all images sorted by line number (JSON appearance order)
                // One entry per unique filename, keeping the first occurrence's config key and line number
                const uniqueImageFiles = new Map();
                loadedImageData.forEach(imageData => {
                    if (!uniqueImageFiles.has(imageData.filename)) {
                        uniqueImageFiles.set(imageData.filename, {
                            type: 'image',
                            filename: imageData.filename,
                            displayName: imageData.configKey,
                            resourceValue: imageData.filename,
                            objectUrl: imageData.objectUrl,
                            url: imageData.url,
                            lineNumber: imageData.lineNumber
                        });
                    }
                });

                // Convert to array and sort by line number
                const sortedImages = Array.from(uniqueImageFiles.values()).sort((a, b) => {
                    if (a.lineNumber !== b.lineNumber) {
                        return a.lineNumber - b.lineNumber;
                    }
                    return a.filename.localeCompare(b.filename);
                });
                window.assetNavigation.assets.push(...sortedImages);

                // Collect unique transparent files and their config keys
                const transparentAssetsList = [];
                const transparentFilesSet = new Set();
                transparentFilesMap.forEach((configKeys, filename) => {
                    if (/^transparent\./i.test(filename)) {
                        const baseName = filename.replace(/\.[^.]+$/, '');
                        if (!transparentFilesSet.has(baseName)) {
                            transparentFilesSet.add(baseName);
                            transparentAssetsList.push(...configKeys);
                        }
                    }
                });
                const uniqueTransparentFiles = transparentFilesSet.size;
                const uniqueTransparentConfigKeys = [...new Set(transparentAssetsList)];

                if (loadedImageData.length === 0 && uniqueTransparentFiles === 0 && !fontFile) {
                    carouselWrapper.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">No images found</div>';
                    if (carouselInfo) carouselInfo.textContent = '0 / 0';
                    return;
                }

                // Create carousel items - starting with spinal resources first
                // 1. index.html (first)
                const indexHtmlItem = document.createElement('div');
                indexHtmlItem.className = 'image-carousel-item';
                indexHtmlItem.onclick = function (e) {
                    e.stopPropagation();
                    // Find and set asset index BEFORE opening lightbox
                    if (window.assetNavigation.assets) {
                        const htmlIndex = window.assetNavigation.assets.findIndex(a => a.filename === 'index.html');
                        if (htmlIndex >= 0) {
                            window.assetNavigation.currentIndex = htmlIndex;
                        }
                    }
                    openLightbox('index-html', null, null);
                };
                indexHtmlItem.style.cursor = 'pointer';

                // Create HTML icon/preview thumbnail with HTML file symbol
                const htmlThumbnailDiv = document.createElement('div');
                htmlThumbnailDiv.style.cssText = 'width: 120px; height: 80px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 4px; display: flex; align-items: center; justify-content: center; color: white; font-size: 2.5rem; text-align: center; padding: 10px; box-sizing: border-box; position: relative;';
                htmlThumbnailDiv.innerHTML = 'üìÑ';
                // Add HTML badge
                const htmlBadge = document.createElement('div');
                htmlBadge.style.cssText = 'position: absolute; bottom: 8px; right: 8px; background: rgba(255,255,255,0.9); color: #667eea; font-size: 0.65rem; font-weight: 700; padding: 2px 5px; border-radius: 3px; font-family: monospace;';
                htmlBadge.textContent = 'HTML';
                htmlThumbnailDiv.appendChild(htmlBadge);

                const htmlLabel = document.createElement('div');
                htmlLabel.className = 'image-name';
                htmlLabel.textContent = 'index.html';

                indexHtmlItem.appendChild(htmlThumbnailDiv);
                indexHtmlItem.appendChild(htmlLabel);
                carouselWrapper.appendChild(indexHtmlItem);

                // 2. config.json (second)
                if (config) {
                    const configItem = document.createElement('div');
                    configItem.className = 'image-carousel-item';
                    configItem.onclick = function (e) {
                        e.stopPropagation();
                        // Find and set asset index BEFORE opening lightbox
                        if (window.assetNavigation.assets) {
                            const configIndex = window.assetNavigation.assets.findIndex(a => a.filename === 'config.json');
                            if (configIndex >= 0) {
                                window.assetNavigation.currentIndex = configIndex;
                            }
                        }
                        openLightbox('config-json', null, config, null, null, imageCache, fontFile);
                    };
                    configItem.style.cursor = 'pointer';

                    // Create JSON icon/preview thumbnail with cog/settings symbol
                    const thumbnailDiv = document.createElement('div');
                    thumbnailDiv.style.cssText = 'width: 120px; height: 80px; background: #2d2d2d; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #f8f8f2; font-size: 2.2rem; text-align: center; padding: 10px; box-sizing: border-box; border: 2px solid #555; position: relative;';
                    thumbnailDiv.innerHTML = '‚öô';
                    // Add JSON badge
                    const jsonBadge = document.createElement('div');
                    jsonBadge.style.cssText = 'position: absolute; bottom: 8px; right: 8px; background: rgba(255,255,255,0.9); color: #2d2d2d; font-size: 0.6rem; font-weight: 700; padding: 2px 5px; border-radius: 3px; font-family: monospace;';
                    jsonBadge.textContent = 'JSON';
                    thumbnailDiv.appendChild(jsonBadge);

                    const label = document.createElement('div');
                    label.className = 'image-name';
                    label.textContent = 'config.json';

                    configItem.appendChild(thumbnailDiv);
                    configItem.appendChild(label);
                    carouselWrapper.appendChild(configItem);
                }

                // 3. fontFamily (third)
                if (fontFile) {
                    // Load font and create preview thumbnail
                    try {
                        const fontUrl = getGitHubRawUrl(fontFile);
                        const localFontUrl = getLocalUrl(fontFile);

                        // Create font preview thumbnail
                        const fontItem = document.createElement('div');
                        fontItem.className = 'image-carousel-item';

                        // Create canvas for font preview thumbnail
                        const canvas = document.createElement('canvas');
                        canvas.width = 120;
                        canvas.height = 80;
                        const ctx = canvas.getContext('2d');

                        // Try to load font and draw preview
                        const loadFontPreview = async () => {
                            try {
                                const fontFace = new FontFace('PreviewFont', `url(${fontUrl})`);
                                await fontFace.load();
                                document.fonts.add(fontFace);

                                ctx.fillStyle = '#fff';
                                ctx.fillRect(0, 0, 120, 80);
                                ctx.fillStyle = '#333';
                                ctx.font = 'bold 16px PreviewFont';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText('AaBbCc', 60, 40);
                            } catch (e) {
                                // Fallback: show font icon
                                ctx.fillStyle = '#f0f0f0';
                                ctx.fillRect(0, 0, 120, 80);
                                ctx.fillStyle = '#666';
                                ctx.font = 'bold 20px sans-serif';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText('Aa', 60, 40);
                            }
                        };

                        loadFontPreview().then(() => {
                            fontItem.onclick = function (e) {
                                e.stopPropagation();
                                // Find and set asset index BEFORE opening lightbox
                                if (window.assetNavigation.assets) {
                                    const fontIndex = window.assetNavigation.assets.findIndex(a =>
                                        a.type === 'font' && (a.filename === fontFile || a.resourceValue === fontFile)
                                    );
                                    if (fontIndex >= 0) {
                                        window.assetNavigation.currentIndex = fontIndex;
                                    }
                                }
                                openLightbox('font-preview', fontFile, null, fontUrl, localFontUrl, imageCache, null, fontFile);
                            };
                            fontItem.style.cursor = 'pointer';

                            const thumbnailImg = document.createElement('img');
                            thumbnailImg.src = canvas.toDataURL();
                            thumbnailImg.style.cssText = 'width: 120px; height: 80px; object-fit: contain; border-radius: 4px; background: white;';
                            thumbnailImg.alt = fontFile;

                            const label = document.createElement('div');
                            label.className = 'image-name';
                            label.textContent = `fontFamily: ${fontFile}`;

                            fontItem.appendChild(thumbnailImg);
                            fontItem.appendChild(label);
                            carouselWrapper.appendChild(fontItem);
                        });
                    } catch (e) {
                        console.warn('Could not create font preview:', e);
                    }
                }

                // Create carousel items for images only - in navigation order (sorted by line number)
                // Special items (index.html, config.json, font) are already added above
                // Get all image assets from navigation array (excluding special items)
                const imageAssets = window.assetNavigation.assets.filter(a => a.type === 'image');

                imageAssets.forEach((asset) => {
                    const item = document.createElement('div');
                    item.className = 'image-carousel-item';
                    item.style.cursor = 'pointer';

                    item.onclick = function (e) {
                        e.stopPropagation();
                        // Find and set asset index BEFORE opening lightbox
                        if (window.assetNavigation.assets) {
                            const assetIndex = window.assetNavigation.assets.findIndex(a =>
                                a.type === 'image' &&
                                (a.filename === asset.filename || a.resourceValue === asset.resourceValue)
                            );
                            if (assetIndex >= 0) {
                                window.assetNavigation.currentIndex = assetIndex;
                            }
                        }
                        openLightbox(asset.objectUrl || asset.url, asset.filename, null, null, null, imageCache, null, asset.resourceValue || asset.filename);
                    };

                    // Check if image is fully transparent
                    const cached = imageCache.get(asset.filename);
                    if (cached && cached.isTransparent) {
                        // Show transparent indicator instead of image
                        const transparentIndicator = document.createElement('div');
                        transparentIndicator.style.cssText = 'width: 100%; height: 80px; display: flex; align-items: center; justify-content: center; background-image: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #f0f0f0 75%), linear-gradient(-45deg, transparent 75%, #f0f0f0 75%); background-size: 12px 12px; background-position: 0 0, 0 6px, 6px -6px, -6px 0px; border-radius: 4px; border: 1px solid #ddd; padding: 4px; box-sizing: border-box;';
                        const transparentLabel = document.createElement('div');
                        transparentLabel.style.cssText = 'text-align: center; color: #999; font-size: 0.7rem; font-weight: 600; padding: 5px; background: rgba(255, 255, 255, 0.9); border-radius: 3px;';
                        transparentLabel.textContent = 'Transparent (No Image)';
                        transparentIndicator.appendChild(transparentLabel);
                        item.appendChild(transparentIndicator);
                    } else {
                        const img = document.createElement('img');
                        img.src = asset.objectUrl || asset.url;
                        img.alt = asset.filename;
                        img.loading = 'lazy';
                        item.appendChild(img);
                    }

                    const label = document.createElement('div');
                    label.className = 'image-name';
                    label.textContent = asset.displayName;
                    label.title = asset.filename; // Show filename on hover
                    item.appendChild(label);

                    carouselWrapper.appendChild(item);
                });

                updateCarouselInfo();

                console.log(`‚úÖ Cached ${fileCache.size} image files for faster download/install`);

            } catch (error) {
                console.error('Error loading theme images:', error);
                carouselWrapper.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">Error loading images</div>';
            }
        }

        // Update carousel info (current / total)
        function updateCarouselInfo() {
            const carouselInfo = document.getElementById('carousel-info');
            const items = document.querySelectorAll('.image-carousel-item');
            if (carouselInfo) {
                carouselInfo.textContent = `${items.length} / ${items.length}`;
            }
        }

        // Carousel navigation (scroll)
        function scrollCarousel(direction) {
            const wrapper = document.getElementById('image-carousel-wrapper');
            if (!wrapper) return;

            const scrollAmount = 130; // Width of item + gap
            wrapper.scrollBy({
                left: direction * scrollAmount,
                behavior: 'smooth'
            });
        }

        // Load images when page loads
        document.addEventListener('DOMContentLoaded', () => {
            loadScreenshots(); // Load screenshots gallery first
            loadThemeImages(); // Then load theme assets
        });
    </script>

</body>

</html>

</html>